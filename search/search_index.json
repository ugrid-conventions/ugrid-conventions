{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UGRID Conventions (v1.0) \uf0c1 UGRID Conventions (v1.0) Introduction Known issues Topology Naming conventions for geometrical elements 1D network topology 2D triangular mesh topology 2D flexible mesh (mixed triangles, quadrilaterals, etc.) topology 3D layered mesh topology Fully 3D unstructured (i.e. non-layered) mesh topology Data defined on unstructured meshes Data variables Volume and flux variables Location index set Zero or One-based indexing Introduction \uf0c1 This page describes a proposal for storing unstructured (or flexible mesh) model data in the Unidata Network Common Data Form (NetCDF) file. Our focus is on data for environmental applications and hence we start from the Climate & Forecast (CF) Metadata Conventions . The CF Conventions have been the standard in climate research for many years, and are being adopted by others as the metadata standard (e.g. NASA , Open Geospatial Consortium ). The CF conventions allow you to provide the geospatial and temporal coordinates for scientific data, but currently assumes that the horizontal topology may be inferred from the i,j indices of structured grids. This proposal adds conventions for specifying the topology for unstructured (e.g. triangular) grids. In its most basic form unstructured data may be stored as data defined at a series of points, the CF-conventions are then sufficient. However, it is often useful or even necessary to also know the topology of the underlying unstructured mesh: is it a one dimensional (1D) network, a two dimensional (2D) triangular mesh or more flexible mixed triangle/quadrilateral mesh, a 2D mesh with vertical layers, or a fully unstructured three dimensional (3D) mesh. This document describes the attribute conventions for storing the mesh topology and for associating variables with (specific locations on) the mesh topology. The conventions have been designed to store the output data of a combined 1D-2D-3D flow model with staggered data, but the metadata for a simple 1D network or 2D triangular mesh doesn\u2019t suffer from the genericity needed for the most complex models. Due to the complexity in unstructured mesh models, some concepts have not yet been worked out in this version. Known issues \uf0c1 Known issues left for future versions include: adaptive mesh topology (this could be supported by defining a time_concatenation attribute for a time-series of mesh topologies) higher order element data; for an idea how such data could be stored see this other proposal . subgrid data; the NetCDF pages by the Bundesanstalt f\u00fcr Wasserbau (BAW) contain some proposals on this topic ( see their pages ). 3D fully unstructured meshes (some concepts are included here, but still somewhat limited in scope). multiply-connected domains ghost elements Topology \uf0c1 Naming conventions for geometrical elements \uf0c1 Inspired by Wikipedia\u2019s definition of network topology , we define the mesh topology here as the interconnection of various geometrical elements of the mesh. The pure interconnectivity is independent of georeferencing the individual geometrical elements, but for the practical applications for which we are defining this CF extension, we\u2019ll always add coordinate data. Within a mesh, one can distinguish 0-, 1-, 2- and 3-dimensional elements. We need some names to identify these four types of elements; after discussion we propose the following names: Dimensionality Proposed Name Comments 0 node A point, a coordinate pair or triplet: the most basic element of the topology. The word \u201cnode\u201d seems to be more commonly used than the alternative \u201cvertex\u201d. 1 edge A line or curve bounded by two nodes. 2 face A plane or surface enclosed by a set of edges. In a 2D horizontal application one may consider the word \u201cpolygon\u201d, but in the hierarchy of elements the word \u201cface\u201d is most common. 3 volume A volume enclosed by a set of faces. The alternative word \u201ccell\u201d was considered, but \u201ccell\u201d is often used in the community to describe 2 dimensional structures. In favor of simpler code for interpreting compliant files, we have dropped to use of the locations attribute which allowed the user to specify his/her own names for nodes, edges, faces and volumes. 1D network topology \uf0c1 The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh1\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 1 node_coordinates edge_node_connectivity Optional attributes edge_coordinates The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a 1D network this should be 1. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute edge_node_connectivity points to an index variable identifying for every edge to the indices of its begin and end nodes. The connectivity array will thus be a matrix of size nEdges x 2. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh1_edge_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. The option to support both 0- and 1-based indexing was introduced to be able to support existing files with 1-based index tables using ncML. See this section on zero or one-based indexing for more details. The mesh_topology may optionally include an edge_coordinates attribute which points to the auxiliary coordinate variables associated with the characteristic location of the edge (commonly the midpoint). These auxiliary coordinate variables will have length nEdges, and may have in turn a bounds attribute that specifies the bounding coordinates of the edge (thereby duplicating the data in the node_coordinates variables). This use of the bounds attribute is consistent with the CF-convention on the use of bounds for multi-dimensional coordinate variables with p-sided cells, but it may not strictly be supported by the CF-convention right now. Example: dimensions: nMesh1_node = 5 ; // nNodes nMesh1_edge = 4 ; // nEdges Two = 2; variables: // Mesh topology integer Mesh1 ; Mesh1:cf_role = \"mesh_topology\" ; Mesh1:long_name = \"Topology data of 1D network\" ; Mesh1:topology_dimension = 1 ; Mesh1:node_coordinates = \"Mesh1_node_x Mesh1_node_y\" ; Mesh1:edge_node_connectivity = \"Mesh1_edge_nodes\" ; Mesh1:edge_coordinates = \"Mesh1_edge_x Mesh1_edge_y\" ; // optional attribute integer Mesh1_edge_nodes(nMesh1_edge, Two) ; Mesh1_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh1_edge_nodes:long_name = \"Maps every edge/link to the two nodes that it connects.\" ; Mesh1_edge_nodes:start_index = 1 ; // Mesh node coordinates double Mesh1_node_x(nMesh1_node) ; Mesh1_node_x:standard_name = \"longitude\" ; Mesh1_node_x:long_name = \"Longitude of 1D network nodes.\" ; Mesh1_node_x:units = \"degrees_east\" ; double Mesh1_node_y(nMesh1_node) ; Mesh1_node_y:standard_name = \"latitude\" ; Mesh1_node_y:long_name = \"Latitude of 1D network nodes.\" ; Mesh1_node_y:units = \"degrees_north\" ; // Optional mesh edge coordinate variables double Mesh1_edge_x(nMesh1_edge) ; Mesh1_edge_x:standard_name = \"longitude\" ; Mesh1_edge_x:long_name = \"Characteristic longitude of 1D network edge (e.g. midpoint of the edge).\" ; Mesh1_edge_x:units = \"degrees_east\" ; Mesh1_edge_x:bounds = \"Mesh1_edge_xbnds\" ; double Mesh1_edge_y(nMesh1_edge) ; Mesh1_edge_y:standard_name = \"latitude\" ; Mesh1_edge_y:long_name = \"Characteristic latitude of 1D network edge (e.g. midpoint of the edge).\" ; Mesh1_edge_y:units = \"degrees_north\" ; Mesh1_edge_y:bounds = \"Mesh1_edge_ybnds\" ; double Mesh1_edge_xbnds(nMesh1_edge,Two) ; Mesh1_edge_xbnds:standard_name = \"longitude\" ; Mesh1_edge_xbnds:long_name = \"Longitude bounds of 1D network edge (i.e. begin and end longitude).\" ; Mesh1_edge_xbnds:units = \"degrees_east\" ; double Mesh1_edge_ybnds(nMesh1_edge,Two) ; Mesh1_edge_ybnds:standard_name = \"latitude\" ; Mesh1_edge_ybnds:long_name = \"Latitude bounds of 1D network edge (i.e. begin and end latitude).\" ; Mesh1_edge_ybnds:units = \"degrees_north\" ; 2D triangular mesh topology \uf0c1 The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh2\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 2 node_coordinates face_node_connectivity Optionally required attributes * face_dimension edge_node_connectivity edge_dimension Optional attributes face_edge_connectivity face_face_connectivity edge_face_connectivity boundary_node_connectivity face_coordinates edge_coordinates *The \u201cOptionally required\u201d attribute edge_node_connectivity is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges). *The \u201cOptionally required\u201d attributes face_dimension and edge_dimension are required only if the dimension ordering is nonstandard in any of the connectivity variables for faces and edges, respectively. The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a 2-dimensional (triangular) mesh this should be 2. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute face_node_connectivity points to an index variable identifying for every face (here consistently triangle) the indices of its three corner nodes. The corner nodes should be specified in anticlockwise (also referred to as counterclockwise) direction as viewed from above (consistent with the CF-convention for bounds of p-sided cells). The connectivity array will thus be a matrix of size nFaces x 3. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. See this section on zero or one-based indexing for more details. The face_dimension attribute specifies which netcdf dimension is used to indicate the index of the face in the connectivity arrays. This is needed because some applications store the data with the fastest varying index first, and some with that index last. The default is to use the num_faces as fastest dimension; e.g. a (num_faces, 3) array for triangles, but some applications might use a (3, num_faces) order, in which case the face_dimension attribute is required to help the client code disambiguate. The edge_dimension attribute is similar for the edge connectivity arrays. In case you want to define variables on the edges of the triangular mesh topology you need to specify the edge_node_connectivity attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of edge_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default. Since it does not apply to edges globally, specifying the boundary_node_connectivity attribute described below does not (in and of itself) necessitate the need to specify the edge_node_connectivity attribute too. Optionally the topology may have the following attributes: * face_edge_connectivity pointing to an index variable identifying for every face (here consistently triangle) the indices of its three edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will thus be a matrix of size nFaces x 3. Again the indexing convention of face_edge_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default. * face_face_connectivity pointing to an index variable identifying all faces (here consistently triangle) that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x 3. Again the indexing convention of face_face_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. Attribute _FillValue must be present. Missing neighbor faces are expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_face_links below. * edge_face_connectivity pointing to an index variable identifying all faces that share the same edge, i. e. are neighbors to an edge. This connectivity array is thus a matrix of size nEdges x 2. It is intended to be used in combination with data defined on edges. The start_index attribute should be used to specify the indexing convention and 0-based indexing is the default. Attribute _FillValue must be present. Missing neighbor faces are expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_edge_face_links below. * boundary_node_connectivity pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects. Again the indexing convention of boundary_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default. Although constructed of edges, boundaries represent a different quantity than general edge data and thus the boundary_node_connectivity attribute may be specified independent of edge_node_connectivity . Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1. * face_coordinates and/or edge_coordinates pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a bounds attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the node_coordinates variables). Example: dimensions: nMesh2_node = 4 ; // nNodes nMesh2_edge = 5 ; // nEdges nMesh2_face = 2 ; // nFaces Two = 2 ; Three = 3 ; variables: // Mesh topology integer Mesh2 ; Mesh2:cf_role = \"mesh_topology\" ; Mesh2:long_name = \"Topology data of 2D unstructured mesh\" ; Mesh2:topology_dimension = 2 ; Mesh2:node_coordinates = \"Mesh2_node_x Mesh2_node_y\" ; Mesh2:face_node_connectivity = \"Mesh2_face_nodes\" ; Mesh2:face_dimension = \"nMesh2_face\" ; Mesh2:edge_node_connectivity = \"Mesh2_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh2:edge_dimension = \"nMesh2_edge\" ; Mesh2:edge_coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_coordinates = \"Mesh2_face_x Mesh2_face_y\" ; // optional attribute Mesh2:face_edge_connectivity = \"Mesh2_face_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_face_connectivity = \"Mesh2_face_links\" ; // optional attribute Mesh2:edge_face_connectivity = \"Mesh2_edge_face_links\" ; // optional attribute (requires edge_node_connectivity) integer Mesh2_face_nodes(nMesh2_face, Three) ; Mesh2_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh2_face_nodes:long_name = \"Maps every triangular face to its three corner nodes.\" ; Mesh2_face_nodes:start_index = 1 ; integer Mesh2_edge_nodes(nMesh2_edge, Two) ; Mesh2_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh2_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh2_edge_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, Three) ; Mesh2_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh2_face_edges:long_name = \"Maps every triangular face to its three edges.\" ; Mesh2_face_edges:start_index = 1 ; integer Mesh2_face_links(nMesh2_face, Three) ; Mesh2_face_links:cf_role = \"face_face_connectivity\" ; Mesh2_face_links:long_name = \"neighbor faces for faces\" ; Mesh2_face_links:start_index = 1 ; Mesh2_face_links:_FillValue = -999 ; Mesh2_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; integer Mesh2_edge_face_links(nMesh2_edge, Two) ; Mesh2_edge_face_links:cf_role = \"edge_face_connectivity\" ; Mesh2_edge_face_links:long_name = \"neighbor faces for edges\" ; Mesh2_edge_face_links:start_index = 1 ; Mesh2_edge_face_links:_FillValue = -999 ; Mesh2_edge_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_x:units = \"degrees_east\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_y:units = \"degrees_north\" ; double Mesh2_edge_x(nMesh2_edge) ; Mesh2_edge_x:standard_name = \"longitude\" ; Mesh2_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_x:units = \"degrees_east\" ; double Mesh2_edge_y(nMesh2_edge) ; Mesh2_edge_y:standard_name = \"latitude\" ; Mesh2_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_y:units = \"degrees_north\" ; 2D flexible mesh (mixed triangles, quadrilaterals, etc.) topology \uf0c1 The case of a 2D mesh with mixed face sizes is identical to the 2D triangular mesh discussed above with the exception that not all faces have the same number of nodes. To support this variability we may use in the future a ragged array, but here we propose to use _FillValue to indicate faces with smaller number of nodes than the arrays allow. The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh2\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 2 node_coordinates face_node_connectivity Optionally required attributes * face_dimension edge_node_connectivity edge_dimension Optional attributes face_edge_connectivity face_face_connectivity edge_face_connectivity boundary_node_connectivity face_coordinates edge_coordinates *The \u201cOptionally required\u201d attribute edge_node_connectivity is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges). *The \u201cOptionally required\u201d attributes face_dimension and edge_dimension are required only if the dimension ordering is nonstandard in any of the connectivity variables for faces and edges, respectively. The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a 2-dimensional mesh this should be 2. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute face_node_connectivity points to an index variable identifying for every face the indices of its corner nodes. The corner nodes should be specified in anticlockwise direction as viewed from above (consistent with the CF-convention for bounds of p-sided cells). The connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace; if a face has less corner nodes than MaxNumNodesPerFace then the last node indices shall be equal to _FillValue (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. See this section on zero or one-based indexing for more details. The face_dimension attribute specifies which netcdf dimension is used to indicate the index of the face in the connectivity arrays. This is needed because some applications store the data with the fastest varying index first, and some with that index last. The default is to use the num_faces as fastest dimension; e.g. a (num_faces, 4) array for quads, but some applications might use a (4, num_faces) order, in which case the face_dimension attribute is required to help the client code disambiguate. The edge_dimension attribute is similar for the edge connectivity arrays. In case you want to define variables on the edges of the 2D mesh topology you need to specify the edge_node_connectivity attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of edge_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default. Since it does not apply to edges globally, specifying the boundary_node_connectivity attribute described below does not (in and of itself) necessitate the need to specify the edge_node_connectivity attribute too. Optionally the topology may have the following attributes: * face_edge_connectivity pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to _FillValue , and the indexing convention of face_edge_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default. * face_face_connectivity pointing to an index variable identifying all faces that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last face (column) indices shall be equal to _FillValue , and the indexing convention of face_face_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. Missing neighbor faces are also expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_face_links below. * edge_face_connectivity pointing to an index variable identifying all faces that share the same edge, i. e. are neighbors to an edge. This connectivity array is thus a matrix of size nEdges x 2. It is intended to be used in combination with data defined on edges. The start_index attribute should be used to specify the indexing convention and 0-based indexing is the default. Attribute _FillValue must be present. Missing neighbor faces are expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_edge_face_links below. * boundary_node_connectivity pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects. Again the indexing convention of boundary_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default. Although constructed of edges, boundaries represent a different quantity than general edge data and thus the boundary_node_connectivity attribute may be specified independent of edge_node_connectivity . Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1. * face_coordinates and/or edge_coordinates pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a bounds attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the node_coordinates variables). The use of _FillValue to indicate faces with fewer nodes than MaxNumNodesPerFace extends to the coordinate bounds variables; this is an extension of the current convention. Example: dimensions: nMesh2_node = 5 ; // nNodes nMesh2_edge = 6 ; // nEdges nMesh2_face = 2 ; // nFaces nMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace Two = 2 ; variables: // Mesh topology integer Mesh2 ; Mesh2:cf_role = \"mesh_topology\" ; Mesh2:long_name = \"Topology data of 2D unstructured mesh\" ; Mesh2:topology_dimension = 2 ; Mesh2:node_coordinates = \"Mesh2_node_x Mesh2_node_y\" ; Mesh2:face_node_connectivity = \"Mesh2_face_nodes\" ; Mesh2:face_dimension = \"nMesh2_face\" ; Mesh2:edge_node_connectivity = \"Mesh2_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh2:edge_dimension = \"nMesh2_edge\" ; Mesh2:edge_coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_coordinates = \"Mesh2_face_x Mesh2_face_y\" ; // optional attribute Mesh2:face_edge_connectivity = \"Mesh2_face_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_face_connectivity = \"Mesh2_face_links\" ; // optional attribute Mesh2:edge_face_connectivity = \"Mesh2_edge_face_links\" ; // optional attribute (requires edge_node_connectivity) integer Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh2_face_nodes:long_name = \"Maps every face to its corner nodes.\" ; Mesh2_face_nodes:_FillValue = 999999 ; Mesh2_face_nodes:start_index = 1 ; integer Mesh2_edge_nodes(nMesh2_edge, Two) ; Mesh2_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh2_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh2_edge_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh2_face_edges:long_name = \"Maps every face to its edges.\" ; Mesh2_face_edges:_FillValue = 999999 ; Mesh2_face_edges:start_index = 1 ; integer Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_links:cf_role = \"face_face_connectivity\" ; Mesh2_face_links:long_name = \"neighbor faces for faces\" ; Mesh2_face_links:start_index = 1 ; Mesh2_face_links:_FillValue = -999 ; Mesh2_face_links:comment = \"missing edges as well as missing neighbor faces are indicated using _FillValue\" ; integer Mesh2_edge_face_links(nMesh2_edge, Two) ; Mesh2_edge_face_links:cf_role = \"edge_face_connectivity\" ; Mesh2_edge_face_links:long_name = \"neighbor faces for edges\" ; Mesh2_edge_face_links:start_index = 1 ; Mesh2_edge_face_links:_FillValue = -999 ; Mesh2_edge_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh face.\" ; Mesh2_face_x:units = \"degrees_east\" ; Mesh2_face_x:bounds = \"Mesh2_face_xbnds\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh face.\" ; Mesh2_face_y:units = \"degrees_north\" ; Mesh2_face_y:bounds = \"Mesh2_face_ybnds\" ; double Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_xbnds:standard_name = \"longitude\" ; Mesh2_face_xbnds:long_name = \"Longitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_xbnds:units = \"degrees_east\" ; Mesh2_face_xbnds:_FillValue = 9.9692099683868690E36; double Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_ybnds:standard_name = \"latitude\" ; Mesh2_face_ybnds:long_name = \"Latitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_ybnds:units = \"degrees_north\" ; Mesh2_face_ybnds:_FillValue = 9.9692099683868690E36; double Mesh2_edge_x(nMesh2_edge) ; Mesh2_edge_x:standard_name = \"longitude\" ; Mesh2_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_x:units = \"degrees_east\" ; double Mesh2_edge_y(nMesh2_edge) ; Mesh2_edge_y:standard_name = \"latitude\" ; Mesh2_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_y:units = \"degrees_north\" ; // bounds variables for edges skipped 3D layered mesh topology \uf0c1 For a 3D layered unstructured mesh topology this proposal follows the approach of the existing CF-conventions for structured meshes: horizontal and vertical dimensions are treated separately. For the horizontal plane a 2D unstructured mesh topology is defined, which is extruded in the vertical direction by means of a vertical coordinate . The example below matches the example in the previous section combined with a vertical coordinate according CF-conventions. This example introduces also the attributes mesh and location on the 2D variables \u201cMesh2_surface\u201d and \u201cMesh2_depth\u201d. For more information about these attributes see the data definition section below. Example: dimensions: nMesh2_node = 6 ; // nNodes nMesh2_edge = 7 ; // nEdges nMesh2_face = 2 ; // nFaces nMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace Mesh2_layers = 10 ; Two = 2 ; variables: // Mesh topology integer Mesh2 ; Mesh2:cf_role = \"mesh_topology\" ; Mesh2:long_name = \"Topology data of 2D unstructured mesh\" ; Mesh2:topology_dimension = 2 ; Mesh2:node_coordinates = \"Mesh2_node_x Mesh2_node_y\" ; Mesh2:face_node_connectivity = \"Mesh2_face_nodes\" ; Mesh2:face_dimension = \"nMesh2_face\" ; Mesh2:edge_node_connectivity = \"Mesh2_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh2:edge_dimension = \"nMesh2_edge\" ; Mesh2:edge_coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_coordinates = \"Mesh2_face_x Mesh2_face_y\" ; // optional attribute Mesh2:face_edge_connectivity = \"Mesh2_face_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_face_connectivity = \"Mesh2_face_links\" ; // optional attribute Mesh2:edge_face_connectivity = \"Mesh2_edge_face_links\" ; // optional attribute (requires edge_node_connectivity) integer Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh2_face_nodes:long_name = \"Maps every face to its corner nodes.\" ; Mesh2_face_nodes:_FillValue = 999999 ; Mesh2_face_nodes:start_index = 1 ; integer Mesh2_edge_nodes(nMesh2_edge, Two) ; Mesh2_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh2_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh2_edge_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh2_face_edges:long_name = \"Maps every face to its edges.\" ; Mesh2_face_edges:_FillValue = 999999 ; Mesh2_face_edges:start_index = 1 ; integer Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_links:cf_role = \"face_face_connectivity\" ; Mesh2_face_links:long_name = \"neighbor faces for faces\" ; Mesh2_face_links:start_index = 1 ; Mesh2_face_links:_FillValue = -999 ; Mesh2_face_links:comment = \"missing edges as well as missing neighbor faces are indicated using _FillValue\" ; integer Mesh2_edge_face_links(nMesh2_edge, Two) ; Mesh2_edge_face_links:cf_role = \"edge_face_connectivity\" ; Mesh2_edge_face_links:long_name = \"neighbor faces for edges\" ; Mesh2_edge_face_links:start_index = 1 ; Mesh2_edge_face_links:_FillValue = -999 ; Mesh2_edge_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh face.\" ; Mesh2_face_x:units = \"degrees_east\" ; Mesh2_face_x:bounds = \"Mesh2_face_xbnds\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh face.\" ; Mesh2_face_y:units = \"degrees_north\" ; Mesh2_face_y:bounds = \"Mesh2_face_ybnds\" ; double Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_xbnds:standard_name = \"longitude\" ; Mesh2_face_xbnds:long_name = \"Longitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_xbnds:units = \"degrees_east\" ; Mesh2_face_xbnds:_FillValue = 9.9692099683868690E36; double Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_ybnds:standard_name = \"latitude\" ; Mesh2_face_ybnds:long_name = \"Latitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_ybnds:units = \"degrees_north\" ; Mesh2_face_ybnds:_FillValue = 9.9692099683868690E36; double Mesh2_edge_x(nMesh2_edge) ; Mesh2_edge_x:standard_name = \"longitude\" ; Mesh2_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_x:units = \"degrees_east\" ; double Mesh2_edge_y(nMesh2_edge) ; Mesh2_edge_y:standard_name = \"latitude\" ; Mesh2_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_y:units = \"degrees_north\" ; // bounds variables for edges skipped // Vertical coordinate double Mesh2_layers(Mesh2_layers) ; Mesh2_layers:standard_name = \"ocean_sigma_coordinate\" ; Mesh2_layers:long_name = \"sigma at layer midpoints\" ; Mesh2_layers:positive = \"up\" ; Mesh2_layers:formula_terms = \"sigma: Mesh2_layers eta: Mesh2_surface depth: Mesh2_depth\" ; double Mesh2_depth(nMesh2_node) ; Mesh2_depth:standard_name = \"sea_floor_depth_below_geoid\" ; Mesh2_depth:units = \"m\" ; Mesh2_depth:positive = \"down\" ; Mesh2_depth:mesh = \"Mesh2\" Mesh2_depth:location = \"node\" ; Mesh2_depth:coordinates = \"Mesh2_node_x Mesh2_node_y\" ; double Mesh2_surface(nMesh2_node) ; Mesh2_surface:standard_name = \"sea_surface_height_above_geoid\" ; Mesh2_surface:units = \"m\" ; Mesh2_surface:mesh = \"Mesh2\" Mesh2_surface:location = \"face\" ; Mesh2_surface:coordinates = \"Mesh2_face_x Mesh2_face_y\" ; Fully 3D unstructured (i.e. non-layered) mesh topology \uf0c1 For a fully 3D unstructured mesh topology we extend the hierarchy of nodes, edges and faces to volumes. Contrary to layered case this type of mesh requires a fully 3D specification of the mesh; hence we not only need latitude and longitude coordinates but also some kind of elevation coordinate ( this probably requires a new standard name ). The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh3D\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 3 node_coordinates volume_node_connectivity volume_shape_type Optionally-required attributes * volume_dimension face_node_connectivity face_dimension edge_node_connectivity edge_dimension Optional attributes volume_edge_connectivity volume_face_connectivity volume_volume_connectivity face_edge_connectivity boundary_node_connectivity volume_coordinates face_coordinates edge_coordinates *The \u201cOptionally required\u201d attributes edge_node_connectivity and face_node_connectivity are required only if you want to store data on the edges or faces respectively (i.e. if you mind the numbering order of the edges/faces). *The \u201cOptionally required\u201d attributes volume_dimension , face_dimension and edge_dimension are required only if the dimension ordering is nonstandard in any of the connectivity variables for volumes, faces and nodes, respectively. The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a fully 3-dimensional unstructured mesh this should be 3. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, elevation and optional other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute volume_node_connectivity points to an index variable identifying for every volume the indices of its corner nodes. For faces in the horizontal plane, it was possible to prescribe the order of the nodes, but this is not possible for the nodes of generic 3D volumes. For this reason we introduce an additional attribute volume_shape_type which points to a flag variable that specifies for every volume its shape: flag_meaning name description tetrahedron pyramid with triangular base, 4 nodes pyramid pyramid with square base, a pentahedron, 5 nodes wedge prism with triangular base, a pentahedron, 6 nodes hexahedron distorted cube, 8 nodes These four volume shapes are the ones most commonly used. More shapes can be added; and if necessary, it\u2019s possible to add a generic shape type which allows for specification of the volume shape indirectly via volume_face_connectivity and face_node_connectivity variables. Such a generic shape is not included in this proposal since there is no practical need for such feature at this time. If all volumes have the same shape type, then the shape type could be determined based on the number of nodes per volume. Another option could be to allow the volume_shape_type to specify the shape type directly rather than pointing to a variable. However, for the time being we assume that the currently proposed volume shape type variable doesn\u2019t have too much impact on the performance. The order in which the corner nodes of a volume are specified is fixed given its shape; this approach is common in 3D modeling, see e.g. this graph in the OpenFOAM documentation and ParaView or VTK documentation. The volume_node_connectivity array will be a matrix of size nVolumes x MaxNumNodesPerVolume; if a volume has fewer corner nodes than MaxNumNodesPerVolume then the last node indices shall be equal to _FillValue (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh3D_vol_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. See this section on zero or one-based indexing for more details. The volume_dimension attribute specifies which netcdf dimension is used to indicate the index of the volume in the connectivity arrays. This is needed because some applications store the data with the fastest varying index first, and some with that index last. The default is to use the num_volumes as fastest dimension; e.g. a (num_volumes, 4) array for tetrahedrons, but some applications might use a (4, num_volumes) order, in which case the volume_dimension attribute is required to help the client code disambiguate. The face_dimension and edge_dimension attributes are similar for the face and edge connectivity arrays. In case you want to define variables on the faces or edges of the 3D mesh topology you need to specify the face_node_connectivity or edge_node_connectivity attribute, respectively, to map faces or edges to nodes. Although the volume to node mapping implicitly also defines the location of the faces and edges, it does not specify their global numbering. Again the indexing convention of face_node_connectivity and edge_node_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. Since it does not apply to either nodes or edges globally, specifying the boundary_node_connectivity attribute described below does not (in and of itself) necessitate the need to specify edge_node_connectivity nor face_node_connectivity . Optionally the topology may have the following attributes: volume_face_connectivity pointing to an index variable identifying for every volume the indices of its faces. The order in which the face indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumFacesPerVolume. If a volume has fewer faces than MaxNumFacesPerVolume then the last face indices shall be equal to _FillValue , and the indexing convention of volume_edge_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. volume_edge_connectivity pointing to an index variable identifying for every volume the indices of its edges. The order in which the edge indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumEdgesPerVolume. Again, if a volume has fewer edges than MaxNumEdgesPerVolume then the last edge indices shall be equal to _FillValue , and the indexing convention of volume_edge_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. volume_volume_connectivity pointing to an index variable identifying all volumes that share a face with each volume, i.e. are neighbors. This connectivity array will thus be a matrix of size nVolumes x MaxNumFacesPerVolume with a flag to note if the region \u201cout of mesh\u201d abuts a face of a given volume. Again, if a volume has fewer sides/faces than MaxNumFacesPerVolume then the last volume (column) indices shall be equal to _FillValue , and the indexing convention of volume_volume_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh3D_vol_links in the example below) and 0-based indexing is the default. face_edge_connectivity pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. As always, if a face has fewer corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to _FillValue , and the indexing convention of face_edge_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. face_node_connectivity pointing to an index variable identifying for every face the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to _FillValue , and the indexing convention of face_node_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. boundary_node_connectivity pointing to an index variable identifying for every face of each boundary the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nBoundaryFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to _FillValue , and the indexing convention of boundary_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh3D_boundary_nodes) and 0-based indexing is the default. Although constructed of faces, boundaries represent a different quantity than general face data and thus the boundary_node_connectivity attribute may be specified independent of face_node_connectivity . Information about the nature of each boundary face (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryFaces X 1. volume_coordinates , face_coordinates and/or edge_coordinates pointing to the auxiliary coordinate variables associated with the characteristic location of the volumes, faces and edges. These auxiliary coordinate variables will have length nVolumes, nFaces and nEdges respectively, and may have in turn a bounds attribute that specifies the corner coordinates of the volume, face or edge (thereby duplicating the data in the node_coordinates variables). The order in which the corner coordinates of the volumes is given by the volume geometry type. Example: dimensions: nMesh3D_node = 12 ; // nNodes nMesh3D_edge = 23 ; // nEdges nMesh3D_face = 16 ; // nFaces nMesh3D_vol = 4 ; // nVolumes nMaxMesh3D_face_nodes = 4 ; // MaxNumNodesPerFace nMaxMesh3D_vol_nodes = 8 ; // MaxNumNodesPerVolume nMaxMesh3D_vol_edges = 12 ; // MaxNumEdgesPerVolume nMaxMesh3D_vol_faces = 6 ; // MaxNumFacesPerVolume Two = 2 ; variables: // Mesh topology integer Mesh3D ; Mesh3D:cf_role = \"mesh_topology\" ; Mesh3D:long_name = \"Topology data of 3D unstructured mesh\" ; Mesh3D:topology_dimension = 3 ; Mesh3D:node_coordinates = \"Mesh3D_node_x Mesh3D_node_y Mesh3D_node_z\" ; Mesh3D:volume_shape_type = \"Mesh3D_vol_types\" ; Mesh3D:volume_node_connectivity = \"Mesh3D_vol_nodes\" ; Mesh3D:volume_dimension = nMesh3D_vol ; Mesh3D:face_node_connectivity = \"Mesh3D_face_nodes\" ; // attribute required if variables will be defined on faces Mesh3D:face_dimension = nMesh3D_face ; Mesh3D:edge_node_connectivity = \"Mesh3D_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh3D:edge_dimension = nMesh3D_edge ; Mesh3D:edge_coordinates = \"Mesh3D_edge_x Mesh3D_edge_y Mesh3D_edge_z\" ; // optional attribute (requires edge_node_connectivity) Mesh3D:face_coordinates = \"Mesh3D_face_x Mesh3D_face_y Mesh3D_face_z\" ; // optional attribute (requires face_node_connectivity) Mesh3D:volume_coordinates = \"Mesh3D_vol_x Mesh3D_vol_y Mesh3D_vol_z\" ; // optional attribute Mesh3D:volume_face_connectivity = \"Mesh3D_vol_faces\" ; // optional attribute (requires face_node_connectivity) Mesh3D:volume_edge_connectivity = \"Mesh3D_vol_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh3D:face_edge_connectivity = \"Mesh3D_face_edges\" ; // optional attribute (requires face_node_connectivity and edge_node_connectivity) Mesh3D:volume_volume_connectivity = \"Mesh3D_vol_links\" ; // optional attribute integer Mesh3D_vol_types(nMesh3D_vol) ; Mesh3D_vol_types:cf_role = \"volume_shape_type\" ; Mesh3D_vol_types:long_name = \"Specifies the shape of the individual volumes.\" ; Mesh3D_vol_types:flag_range = 0b, 2b ; Mesh3D_vol_types:flag_values = 0b, 1b, 2b ; Mesh3D_vol_types:flag_meanings = \"tetrahedron wedge hexahedron\" ; integer Mesh3D_vol_nodes(nMesh3D_vol, nMaxMesh3D_vol_nodes) ; Mesh3D_vol_nodes:cf_role = \"volume_node_connectivity\" ; Mesh3D_vol_nodes:long_name = \"Maps every volume to its corner nodes.\" ; Mesh3D_vol_nodes:_FillValue = 999999 ; Mesh3D_vol_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh3D_edge_nodes(nMesh3D_edge, Two) ; Mesh3D_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh3D_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh3D_edge_nodes:start_index = 1 ; integer Mesh3D_face_nodes(nMesh3D_face, nMaxMesh3D_face_nodes) ; Mesh3D_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh3D_face_nodes:long_name = \"Maps every face to its corner nodes.\" ; Mesh3D_face_nodes:_FillValue = 999999 ; Mesh3D_face_nodes:start_index = 1 ; integer Mesh3D_vol_faces(nMesh3D_vol, nMaxMesh3D_vol_faces) ; Mesh3D_vol_faces:cf_role = \"volume_face_connectivity\" ; Mesh3D_vol_faces:long_name = \"Maps every volume to its faces.\" ; Mesh3D_vol_faces:_FillValue = 999999 ; Mesh3D_vol_faces:start_index = 1 ; integer Mesh3D_vol_edges(nMesh3D_vol, nMaxMesh3D_vol_edges) ; Mesh3D_vol_edges:cf_role = \"volume_edge_connectivity\" ; Mesh3D_vol_edges:long_name = \"Maps every volume to its edges.\" ; Mesh3D_vol_edges:_FillValue = 999999 ; Mesh3D_vol_edges:start_index = 1 ; integer Mesh3D_face_edges(nMesh3D_face, nMaxMesh3D_face_nodes) ; Mesh3D_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh3D_face_edges:long_name = \"Maps every face to its edges.\" ; Mesh3D_face_edges:_FillValue = 999999 ; Mesh3D_face_edges:start_index = 1 ; integer Mesh3D_vol_links(nMesh3D_vol, nMaxMesh3D_vol_faces) ; Mesh3D_vol_links:cf_role = \"volume_volume_connectivity\" ; Mesh3D_vol_links:long_name = \"Indicates which other volumes neighbor each volume.\" ; Mesh3D_vol_links:_FillValue = 999999 ; Mesh3D_vol_links:start_index = 1 ; Mesh3D_vol_links:flag_values = -1 ; Mesh3D_vol_links:flag_meanings = \"out_of_mesh\" ; // Mesh node coordinates double Mesh3D_node_x(nMesh3D_node) ; Mesh3D_node_x:standard_name = \"longitude\" ; Mesh3D_node_x:long_name = \"Longitude of 3D mesh nodes.\" ; Mesh3D_node_x:units = \"degrees_east\" ; double Mesh3D_node_y(nMesh3D_node) ; Mesh3D_node_y:standard_name = \"latitude\" ; Mesh3D_node_y:long_name = \"Latitude of 3D mesh nodes.\" ; Mesh3D_node_y:units = \"degrees_north\" ; double Mesh3D_node_z(nMesh3D_node) ; Mesh3D_node_z:standard_name = \"elevation\" ; Mesh3D_node_z:long_name = \"Elevation of 3D mesh nodes.\" ; Mesh3D_node_z:units = \"m\" ; // Optional mesh volume, face and edge coordinate variables double Mesh3D_vol_x(nMesh3D_vol) ; Mesh3D_vol_x:standard_name = \"longitude\" ; Mesh3D_vol_x:long_name = \"Characteristics longitude of mesh volumes.\" ; Mesh3D_vol_x:units = \"degrees_east\" ; Mesh3D_vol_x:bounds = \"Mesh3D_vol_xbnds\" ; double Mesh3D_vol_y(nMesh3D_vol) ; Mesh3D_vol_y:standard_name = \"latitude\" ; Mesh3D_vol_y:long_name = \"Characteristics latitude of mesh volumes.\" ; Mesh3D_vol_y:units = \"degrees_north\" ; Mesh3D_vol_y:bounds = \"Mesh3D_vol_ybnds\" ; double Mesh3D_vol_z(nMesh3D_vol) ; Mesh3D_vol_z:standard_name = \"elevation\" ; Mesh3D_vol_z:long_name = \"Characteristics elevation of mesh volumes.\" ; Mesh3D_vol_z:units = \"m\" ; Mesh3D_vol_z:bounds = \"Mesh3D_vol_zbnds\" ; double Mesh3D_vol_xbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ; Mesh3D_vol_xbnds:standard_name = \"longitude\" ; Mesh3D_vol_xbnds:long_name = \"Longitude bounds of mesh volumes (i.e. corner coordinates).\" ; Mesh3D_vol_xbnds:units = \"degrees_east\" ; Mesh3D_vol_xbnds:_FillValue = 9.9692099683868690E36; double Mesh3D_vol_ybnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ; Mesh3D_vol_ybnds:standard_name = \"latitude\" ; Mesh3D_vol_ybnds:long_name = \"Latitude bounds of mesh volumes (i.e. corner coordinates).\" ; Mesh3D_vol_ybnds:units = \"degrees_north\" ; Mesh3D_vol_ybnds:_FillValue = 9.9692099683868690E36; double Mesh3D_vol_zbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ; Mesh3D_vol_zbnds:standard_name = \"elevation\" ; Mesh3D_vol_zbnds:long_name = \"Elevation bounds of mesh volumes (i.e. corner coordinates).\" ; Mesh3D_vol_zbnds:units = \"m\" ; Mesh3D_vol_zbnds:_FillValue = 9.9692099683868690E36; double Mesh3D_face_x(nMesh3D_face) ; Mesh3D_face_x:standard_name = \"longitude\" ; Mesh3D_face_x:long_name = \"Characteristics longitude of mesh faces.\" ; Mesh3D_face_x:units = \"degrees_east\" ; double Mesh3D_face_y(nMesh3D_face) ; Mesh3D_face_y:standard_name = \"latitude\" ; Mesh3D_face_y:long_name = \"Characteristics latitude of mesh faces.\" ; Mesh3D_face_y:units = \"degrees_north\" ; double Mesh3D_face_z(nMesh3D_face) ; Mesh3D_face_z:standard_name = \"elevation\" ; Mesh3D_face_z:long_name = \"Characteristics elevation of mesh faces.\" ; Mesh3D_face_z:units = \"m\" ; // bounds variables for faces skipped double Mesh3D_edge_x(nMesh3D_edge) ; Mesh3D_edge_x:standard_name = \"longitude\" ; Mesh3D_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh3D_edge_x:units = \"degrees_east\" ; double Mesh3D_edge_y(nMesh3D_edge) ; Mesh3D_edge_y:standard_name = \"latitude\" ; Mesh3D_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh3D_edge_y:units = \"degrees_north\" ; double Mesh3D_edge_z(nMesh3D_edge) ; Mesh3D_edge_z:standard_name = \"elevation\" ; Mesh3D_edge_z:long_name = \"Characteristic elevation of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh3D_edge_z:units = \"m\" ; // bounds variables for edges skipped Data defined on unstructured meshes \uf0c1 According to CF-conventions a variable defined on a structured mesh is specified as double waterlevel(time,nmax,mmax) ; waterlevel:standard_name = \"sea_surface_height_above_geoid\" ; waterlevel:units = \"m\" ; waterlevel:coordinates = \"lat lon\" ; The coordinates attribute refers to the variables that contain the latitude and longitude coordinates. For a curvilinear grid these variables will share two spatial dimensions, here nmax and mmax : lat(nmax,mmax) and lon(nmax,mmax). In numerical models the various quantities are often computed at different locations of the mesh: staggered data. The standard CF-conventions don\u2019t offer specific support for this functionality and thus for every stagger location coordinates need to be provided separately: cell center coordinates, corner point coordinates, u-flux point coordinates, and v-flux point coordinates. The underlying topology of the mesh, i.e. how these coordinates (variable definition locations) relate to each other isn\u2019t stored in the file. This shortcoming is to some degree solved by the gridspec proposal by Venkatramani Balaji and Zhi Liang. We introduce here attributes that link to the topological data defined above. Data variables \uf0c1 The use of the coordinates attribute is copied from the CF-conventions. It is used to map the values of variables defined on the unstructured meshes directly to their location: latitude, longitude, or other spatial coordinates, and optional elevation. To map the variable onto the topology of the underlying mesh, two new attributes have been introduced. First, the attribute mesh points to the mesh_topology variable containing the meta-data attributes of the mesh on which the variable has been defined. Second, the attribute location points to the (stagger) location within the mesh at which the variable is defined. Note that in this example the coordinates attribute is redundant since the coordinates could also be obtained by using the face_coordinates attribute of the \u201cMesh2\u201d variable. double Mesh2_waterlevel(time,nMesh2_face) ; Mesh2_waterlevel:standard_name = \"sea_surface_height_above_geoid\" ; Mesh2_waterlevel:units = \"m\" ; Mesh2_waterlevel:mesh = \"Mesh2\" Mesh2_waterlevel:location = \"face\" ; Mesh2_waterlevel:coordinates = \"Mesh2_face_x Mesh2_face_y\" ; The order of dimensions on a data variable is arbitrary, so nTimeSteps x nLayers x nFaces, nTimeSteps x nFaces x nLayers, nFaces x nLayers x nTimeSeps, etc would all be valid. In line with CF/COARDS and OGC NetCDF-CF we recommend to use the T,Z,Y,X [c order notation] order as much as possible where the unstructured horizontal dimension should be read for Y,X. That is, the order nTimeSteps x nLayers x nFaces [c order notation] is recommended: the nFaces is the fastest increasing dimension, then the nLayers, and finally the nTimeSteps. Volume and flux variables \uf0c1 The same mesh geometry can be used in different ways to schematize the hydrodynamic volumes and fluxes. Let\u2019s take a simple triangular mesh. From a finite volume point of view this mesh will generally be interpreted as consisting of two volumes with triangular base. However, others may use a continuous Galerkin finite element method that can be shown to be equivalent to a subdivision into four volumes. In the former case the two faces correspond to volumes and the fluxes cross the edges. In the latter case the volumes are defined surrounding the four nodes and the fluxes are directed along the edges. The two abbreviated \u201cncdumps\u201d below show how the basic 2D triangular mesh definition can be extended to include this data. The coordinate variables for the volume data now include bounds attributes to define the surface area of the volumes. Note the subtle difference in the long names between the flux variables in the two cases; the standard_name attribute has to make a more formal distinction between the two cases. Variant 1: Volume at faces: dimensions: nMesh2_node = 4 ; // nNodes nMesh2_edge = 5 ; // nEdges nMesh2_face = 2 ; // nFaces Two = 2 ; Three = 3 ; variables: // Mesh topology integer Mesh2 ; // as in 2D triangular mesh example integer Mesh2_face_nodes(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_edge_nodes(nMesh2_edge, Two) ; // as in 2D triangular mesh example // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_face_links(nMesh2_face, Three) ; // as in 2D triangular mesh example // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; // as in 2D triangular mesh example double Mesh2_node_y(nMesh2_node) ; // as in 2D triangular mesh example // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_x:units = \"degrees_east\" ; Mesh2_face_x:bounds = \"Mesh2_face_xbnds\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_y:units = \"degrees_north\" ; Mesh2_face_y:bounds = \"Mesh2_face_ybnds\" ; double Mesh2_face_xbnds(nMesh2_face,Three) ; Mesh2_face_xbnds:standard_name = \"longitude\" ; Mesh2_face_xbnds:long_name = \"Longitude bounds of 2D mesh triangle (i.e. corner coordinates).\" ; Mesh2_face_xbnds:units = \"degrees_east\" ; double Mesh2_face_ybnds(nMesh2_face,Three) ; Mesh2_face_ybnds:standard_name = \"latitude\" ; Mesh2_face_ybnds:long_name = \"Latitude bounds of 2D mesh triangle (i.e. corner coordinates).\" ; Mesh2_face_ybnds:units = \"degrees_north\" ; double Mesh2_edge_x(nMesh2_edge) ; // as in 2D triangular mesh example double Mesh2_edge_y(nMesh2_edge) ; // as in 2D triangular mesh example // Volume and flux data double Mesh2_volumes(nMesh2_face) ; Mesh2_volumes:long_name = \"volumes\" ; Mesh2_volumes:units = \"m3\" ; Mesh2_volumes:mesh = \"Mesh2\" ; Mesh2_volumes:location = \"face\" ; Mesh2_volumes:coordinates = \"Mesh2_face_x Mesh2_face_y\" ; double Mesh2_fluxes(nMesh2_edge) ; Mesh2_fluxes:long_name = \"flux across edge\" ; Mesh2_fluxes:units = \"m3 s-1\" ; Mesh2_fluxes:mesh = \"Mesh2\" Mesh2_fluxes:location = \"edge\" ; Mesh2_fluxes:coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; Variant 2: Volume at nodes: dimensions: nMesh2_node = 4 ; // nNodes nMesh2_edge = 5 ; // nEdges nMesh2_face = 2 ; // nFaces nMaxMesh2_bnds = 6 ; Two = 2 ; Three = 3 ; variables: // Mesh topology integer Mesh2 ; // as in 2D triangular mesh example integer Mesh2_face_nodes(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_edge_nodes(nMesh2_edge, Two) ; // as in 2D triangular mesh example // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_face_links(nMesh2_face, Three) ; // as in 2D triangular mesh example // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; Mesh2_node_x:bounds = \"Mesh2_node_xbnds\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; Mesh2_node_y:bounds = \"Mesh2_node_ybnds\" ; double Mesh2_node_xbnds(nMesh2_node, nMaxMesh2_bnds) ; Mesh2_node_xbnds:standard_name = \"longitude\" ; Mesh2_node_xbnds:long_name = \"List of x-points that form outline of flow volume\" ; Mesh2_node_xbnds:units = \"degrees_east\" ; Mesh2_node_xbnds:_FillValue = 9.9692099683868690E36; double Mesh2_node_ybnds(nMesh2_node, nMaxMesh2_bnds) ; Mesh2_node_ybnds:standard_name = \"latitude\" ; Mesh2_node_ybnds:units = \"degrees_north\" ; Mesh2_node_ybnds:long_name = \"List of y-points that form outline of flow volume\" ; Mesh2_node_xbnds:_FillValue = 9.9692099683868690E36; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; // as in 2D triangular mesh example double Mesh2_face_y(nMesh2_face) ; // as in 2D triangular mesh example double Mesh2_edge_x(nMesh2_edge) ; // as in 2D triangular mesh example double Mesh2_edge_y(nMesh2_edge) ; // as in 2D triangular mesh example // Volume and flux data double Mesh2_volumes(nMesh2_node) ; Mesh2_volumes:long_name = \"volumes\" ; Mesh2_volumes:units = \"m3\" ; Mesh2_volumes:mesh = \"Mesh2\" ; Mesh2_volumes:location = \"node\" ; Mesh2_volumes:coordinates = \"Mesh2_node_x Mesh2_node_y\" ; double Mesh2_fluxes(nMesh2_edge) ; Mesh2_fluxes:long_name = \"flux along edge\" ; Mesh2_fluxes:units = \"m3 s-1\" ; Mesh2_fluxes:mesh = \"Mesh2\" Mesh2_fluxes:location = \"edge\" ; Mesh2_fluxes:coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; Location index set \uf0c1 Some variables may only be defined at specific locations within the mesh, e.g. only at boundary points or at special locations like weirs and gates. To save space and to improve readability, the concept of a location_index_set is introduced. It is basically identical to the compression option in the the CF-conventions except for the fact that the compression works on a (set of) orthogonal coordinate dimension(s) and the location_index_set works on a topology location. The location index set is an integer variable that contains the indices of the locations at which a specific quantity is defined. The example below defines a location index set \u201cMesh1_set\u201d as a subset of the \u201cnode\u201ds of Mesh1 (red points). The attribute location_index_set of the variable \u201cMesh_waterlevel\u201d points to this index set and the coordinates attribute points to the corresponding (subset) of latitude and longitude coordinates. The mesh and location attributes of the location_index_set variable are required; the coordinates attribute is optional. Note that the coordinates attributes on both \u201cMesh1_cell\u201d and \u201cMesh1_waterlevel\u201d are again redundant since the coordinates could also be obtained by using the index set \u201cMesh1_set\u201d and the node_coordinates attribute of the \u201cMesh1\u201d variable. Consistent with all other index variables defined here, the indexing convention of the location index set should be specified using the start_index attribute to the index variable and 0-based indexing is the default. See this section on zero or one-based indexing for more details. Contrary to a coordinate variable, the index set doesn\u2019t have to be monotonic. So, it can be used for creating subsets of the original locations as well as for renumbering the locations. If the location_index_set attribute is used on a variable, then the mesh and location attributes should not also be used on that variable. dimensions: nMesh1_set = 4 ; variables: integer Mesh1_set(nMesh1_set) ; Mesh1_set:cf_role = \"location_index_set\" ; Mesh1_set:long_name = \"Defines Mesh1_set as subset of the nodes of Mesh1.\" ; Mesh1_set:mesh = \"Mesh1\" ; Mesh1_set:location = \"node\" ; Mesh1_set:start_index = 1 ; Mesh1_set:coordinates = \"Mesh1_set_x Mesh1_set_y\" ; double Mesh1_set_x(nMesh1_set) ; Mesh1_set_x:standard_name = \"longitude\" ; Mesh1_set_x:long_name = \"Characteristic longitude of set (e.g. longitude of node).\" ; Mesh1_set_x:units = \"degrees_east\" ; double Mesh1_set_y(nMesh1_set) ; Mesh1_set_y:standard_name = \"latitude\" ; Mesh1_set_y:long_name = \"Characteristic latitude of set (e.g. latitude of node)\" ; Mesh1_set_y:units = \"degrees_north\" ; double Mesh1_waterlevel(time, nMesh1_set) ; Mesh1_waterlevel:standard_name = \"sea_surface_height_above_geoid\" ; Mesh1_waterlevel:units = \"m\" ; Mesh1_waterlevel:location_index_set = \"Mesh1_set\" ; Mesh1_waterlevel:coordinates = \"Mesh1_set_x Mesh1_set_y\" ; Zero or One-based indexing \uf0c1 The indexing using by the CF compression option is 0-based. Therefore, it is most consistent for this CF extension for unstructured data to also use 0-based indexing, which means that points, edges, faces and volumes will be numbered starting with 0. This convention is consistent with languages like C, Java and Python, but unlike Fortran and MATLAB. Since many of the unstructured models have been programmed in Fortran and legacy NetCDF files exist that use 1-based indexing (which could be upgraded to be consistent with this new proposal using ncML if 1-based indexing were allowed), we propose to support both 0- and 1-based indexing by means of the start_index attribute. You will find below two examples of the same network geometry using either 0- or 1-based indexing. Switching between 0- and 1-based indexing is as easy as adding 1 to or subtracting 1 from the indices upon reading or writing depending on the setting of start_index ; allowing both options should only have a minor impact on the reading routines and no effect at all on the rest of your code. Example of 0-based indexing: dimensions: nMesh1_node = 5 ; // nNodes nMesh1_edge = 4 ; // nEdges Two = 2; variables: // Mesh topology integer Mesh1 ; Mesh1:cf_role = \"mesh_topology\" ; Mesh1:long_name = \"Topology data of 1D network\" ; Mesh1:topology_dimension = 1 ; Mesh1:node_coordinates = \"Mesh1_node_x Mesh1_node_y\" ; Mesh1:edge_node_connectivity = \"Mesh1_edge_nodes\" ; Mesh1:edge_coordinates = \"Mesh1_edge_x Mesh1_edge_y\" ; // optional attribute integer Mesh1_edge_nodes(nMesh1_edge, Two) ; Mesh1_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh1_edge_nodes:long_name = \"Maps every edge/link to the two nodes that it connects.\" ; Mesh1_edge_nodes:start_index = 0 ; // default setting, attribute could have been skipped. // Coordinate variables skipped data: Mesh1 = 0 ; // dummy Mesh1_edge_nodes = 0, 2, 1, 2, 2, 3, 3, 4 ; Example of 1-based indexing: dimensions: nMesh1_node = 5 ; // nNodes nMesh1_edge = 4 ; // nEdges Two = 2; variables: // Mesh topology integer Mesh1 ; Mesh1:cf_role = \"mesh_topology\" ; Mesh1:long_name = \"Topology data of 1D network\" ; Mesh1:topology_dimension = 1 ; Mesh1:node_coordinates = \"Mesh1_node_x Mesh1_node_y\" ; Mesh1:edge_node_connectivity = \"Mesh1_edge_nodes\" ; Mesh1:edge_coordinates = \"Mesh1_edge_x Mesh1_edge_y\" ; // optional attribute integer Mesh1_edge_nodes(nMesh1_edge, Two) ; Mesh1_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh1_edge_nodes:long_name = \"Maps every edge/link to the two nodes that it connects.\" ; Mesh1_edge_nodes:start_index = 1 ; // Coordinate variables skipped data: Mesh1 = 0 ; // dummy Mesh1_edge_nodes = 1, 3, 2, 3, 3, 4, 4, 5 ;","title":"Home"},{"location":"#ugrid-conventions-v10","text":"UGRID Conventions (v1.0) Introduction Known issues Topology Naming conventions for geometrical elements 1D network topology 2D triangular mesh topology 2D flexible mesh (mixed triangles, quadrilaterals, etc.) topology 3D layered mesh topology Fully 3D unstructured (i.e. non-layered) mesh topology Data defined on unstructured meshes Data variables Volume and flux variables Location index set Zero or One-based indexing","title":"UGRID Conventions (v1.0)"},{"location":"#introduction","text":"This page describes a proposal for storing unstructured (or flexible mesh) model data in the Unidata Network Common Data Form (NetCDF) file. Our focus is on data for environmental applications and hence we start from the Climate & Forecast (CF) Metadata Conventions . The CF Conventions have been the standard in climate research for many years, and are being adopted by others as the metadata standard (e.g. NASA , Open Geospatial Consortium ). The CF conventions allow you to provide the geospatial and temporal coordinates for scientific data, but currently assumes that the horizontal topology may be inferred from the i,j indices of structured grids. This proposal adds conventions for specifying the topology for unstructured (e.g. triangular) grids. In its most basic form unstructured data may be stored as data defined at a series of points, the CF-conventions are then sufficient. However, it is often useful or even necessary to also know the topology of the underlying unstructured mesh: is it a one dimensional (1D) network, a two dimensional (2D) triangular mesh or more flexible mixed triangle/quadrilateral mesh, a 2D mesh with vertical layers, or a fully unstructured three dimensional (3D) mesh. This document describes the attribute conventions for storing the mesh topology and for associating variables with (specific locations on) the mesh topology. The conventions have been designed to store the output data of a combined 1D-2D-3D flow model with staggered data, but the metadata for a simple 1D network or 2D triangular mesh doesn\u2019t suffer from the genericity needed for the most complex models. Due to the complexity in unstructured mesh models, some concepts have not yet been worked out in this version.","title":"Introduction"},{"location":"#known-issues","text":"Known issues left for future versions include: adaptive mesh topology (this could be supported by defining a time_concatenation attribute for a time-series of mesh topologies) higher order element data; for an idea how such data could be stored see this other proposal . subgrid data; the NetCDF pages by the Bundesanstalt f\u00fcr Wasserbau (BAW) contain some proposals on this topic ( see their pages ). 3D fully unstructured meshes (some concepts are included here, but still somewhat limited in scope). multiply-connected domains ghost elements","title":"Known issues"},{"location":"#topology","text":"","title":"Topology"},{"location":"#naming-conventions-for-geometrical-elements","text":"Inspired by Wikipedia\u2019s definition of network topology , we define the mesh topology here as the interconnection of various geometrical elements of the mesh. The pure interconnectivity is independent of georeferencing the individual geometrical elements, but for the practical applications for which we are defining this CF extension, we\u2019ll always add coordinate data. Within a mesh, one can distinguish 0-, 1-, 2- and 3-dimensional elements. We need some names to identify these four types of elements; after discussion we propose the following names: Dimensionality Proposed Name Comments 0 node A point, a coordinate pair or triplet: the most basic element of the topology. The word \u201cnode\u201d seems to be more commonly used than the alternative \u201cvertex\u201d. 1 edge A line or curve bounded by two nodes. 2 face A plane or surface enclosed by a set of edges. In a 2D horizontal application one may consider the word \u201cpolygon\u201d, but in the hierarchy of elements the word \u201cface\u201d is most common. 3 volume A volume enclosed by a set of faces. The alternative word \u201ccell\u201d was considered, but \u201ccell\u201d is often used in the community to describe 2 dimensional structures. In favor of simpler code for interpreting compliant files, we have dropped to use of the locations attribute which allowed the user to specify his/her own names for nodes, edges, faces and volumes.","title":"Naming conventions for geometrical elements"},{"location":"#1d-network-topology","text":"The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh1\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 1 node_coordinates edge_node_connectivity Optional attributes edge_coordinates The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a 1D network this should be 1. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute edge_node_connectivity points to an index variable identifying for every edge to the indices of its begin and end nodes. The connectivity array will thus be a matrix of size nEdges x 2. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh1_edge_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. The option to support both 0- and 1-based indexing was introduced to be able to support existing files with 1-based index tables using ncML. See this section on zero or one-based indexing for more details. The mesh_topology may optionally include an edge_coordinates attribute which points to the auxiliary coordinate variables associated with the characteristic location of the edge (commonly the midpoint). These auxiliary coordinate variables will have length nEdges, and may have in turn a bounds attribute that specifies the bounding coordinates of the edge (thereby duplicating the data in the node_coordinates variables). This use of the bounds attribute is consistent with the CF-convention on the use of bounds for multi-dimensional coordinate variables with p-sided cells, but it may not strictly be supported by the CF-convention right now. Example: dimensions: nMesh1_node = 5 ; // nNodes nMesh1_edge = 4 ; // nEdges Two = 2; variables: // Mesh topology integer Mesh1 ; Mesh1:cf_role = \"mesh_topology\" ; Mesh1:long_name = \"Topology data of 1D network\" ; Mesh1:topology_dimension = 1 ; Mesh1:node_coordinates = \"Mesh1_node_x Mesh1_node_y\" ; Mesh1:edge_node_connectivity = \"Mesh1_edge_nodes\" ; Mesh1:edge_coordinates = \"Mesh1_edge_x Mesh1_edge_y\" ; // optional attribute integer Mesh1_edge_nodes(nMesh1_edge, Two) ; Mesh1_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh1_edge_nodes:long_name = \"Maps every edge/link to the two nodes that it connects.\" ; Mesh1_edge_nodes:start_index = 1 ; // Mesh node coordinates double Mesh1_node_x(nMesh1_node) ; Mesh1_node_x:standard_name = \"longitude\" ; Mesh1_node_x:long_name = \"Longitude of 1D network nodes.\" ; Mesh1_node_x:units = \"degrees_east\" ; double Mesh1_node_y(nMesh1_node) ; Mesh1_node_y:standard_name = \"latitude\" ; Mesh1_node_y:long_name = \"Latitude of 1D network nodes.\" ; Mesh1_node_y:units = \"degrees_north\" ; // Optional mesh edge coordinate variables double Mesh1_edge_x(nMesh1_edge) ; Mesh1_edge_x:standard_name = \"longitude\" ; Mesh1_edge_x:long_name = \"Characteristic longitude of 1D network edge (e.g. midpoint of the edge).\" ; Mesh1_edge_x:units = \"degrees_east\" ; Mesh1_edge_x:bounds = \"Mesh1_edge_xbnds\" ; double Mesh1_edge_y(nMesh1_edge) ; Mesh1_edge_y:standard_name = \"latitude\" ; Mesh1_edge_y:long_name = \"Characteristic latitude of 1D network edge (e.g. midpoint of the edge).\" ; Mesh1_edge_y:units = \"degrees_north\" ; Mesh1_edge_y:bounds = \"Mesh1_edge_ybnds\" ; double Mesh1_edge_xbnds(nMesh1_edge,Two) ; Mesh1_edge_xbnds:standard_name = \"longitude\" ; Mesh1_edge_xbnds:long_name = \"Longitude bounds of 1D network edge (i.e. begin and end longitude).\" ; Mesh1_edge_xbnds:units = \"degrees_east\" ; double Mesh1_edge_ybnds(nMesh1_edge,Two) ; Mesh1_edge_ybnds:standard_name = \"latitude\" ; Mesh1_edge_ybnds:long_name = \"Latitude bounds of 1D network edge (i.e. begin and end latitude).\" ; Mesh1_edge_ybnds:units = \"degrees_north\" ;","title":"1D network topology"},{"location":"#2d-triangular-mesh-topology","text":"The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh2\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 2 node_coordinates face_node_connectivity Optionally required attributes * face_dimension edge_node_connectivity edge_dimension Optional attributes face_edge_connectivity face_face_connectivity edge_face_connectivity boundary_node_connectivity face_coordinates edge_coordinates *The \u201cOptionally required\u201d attribute edge_node_connectivity is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges). *The \u201cOptionally required\u201d attributes face_dimension and edge_dimension are required only if the dimension ordering is nonstandard in any of the connectivity variables for faces and edges, respectively. The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a 2-dimensional (triangular) mesh this should be 2. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute face_node_connectivity points to an index variable identifying for every face (here consistently triangle) the indices of its three corner nodes. The corner nodes should be specified in anticlockwise (also referred to as counterclockwise) direction as viewed from above (consistent with the CF-convention for bounds of p-sided cells). The connectivity array will thus be a matrix of size nFaces x 3. For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. See this section on zero or one-based indexing for more details. The face_dimension attribute specifies which netcdf dimension is used to indicate the index of the face in the connectivity arrays. This is needed because some applications store the data with the fastest varying index first, and some with that index last. The default is to use the num_faces as fastest dimension; e.g. a (num_faces, 3) array for triangles, but some applications might use a (3, num_faces) order, in which case the face_dimension attribute is required to help the client code disambiguate. The edge_dimension attribute is similar for the edge connectivity arrays. In case you want to define variables on the edges of the triangular mesh topology you need to specify the edge_node_connectivity attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of edge_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default. Since it does not apply to edges globally, specifying the boundary_node_connectivity attribute described below does not (in and of itself) necessitate the need to specify the edge_node_connectivity attribute too. Optionally the topology may have the following attributes: * face_edge_connectivity pointing to an index variable identifying for every face (here consistently triangle) the indices of its three edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will thus be a matrix of size nFaces x 3. Again the indexing convention of face_edge_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default. * face_face_connectivity pointing to an index variable identifying all faces (here consistently triangle) that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x 3. Again the indexing convention of face_face_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. Attribute _FillValue must be present. Missing neighbor faces are expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_face_links below. * edge_face_connectivity pointing to an index variable identifying all faces that share the same edge, i. e. are neighbors to an edge. This connectivity array is thus a matrix of size nEdges x 2. It is intended to be used in combination with data defined on edges. The start_index attribute should be used to specify the indexing convention and 0-based indexing is the default. Attribute _FillValue must be present. Missing neighbor faces are expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_edge_face_links below. * boundary_node_connectivity pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects. Again the indexing convention of boundary_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default. Although constructed of edges, boundaries represent a different quantity than general edge data and thus the boundary_node_connectivity attribute may be specified independent of edge_node_connectivity . Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1. * face_coordinates and/or edge_coordinates pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a bounds attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the node_coordinates variables). Example: dimensions: nMesh2_node = 4 ; // nNodes nMesh2_edge = 5 ; // nEdges nMesh2_face = 2 ; // nFaces Two = 2 ; Three = 3 ; variables: // Mesh topology integer Mesh2 ; Mesh2:cf_role = \"mesh_topology\" ; Mesh2:long_name = \"Topology data of 2D unstructured mesh\" ; Mesh2:topology_dimension = 2 ; Mesh2:node_coordinates = \"Mesh2_node_x Mesh2_node_y\" ; Mesh2:face_node_connectivity = \"Mesh2_face_nodes\" ; Mesh2:face_dimension = \"nMesh2_face\" ; Mesh2:edge_node_connectivity = \"Mesh2_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh2:edge_dimension = \"nMesh2_edge\" ; Mesh2:edge_coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_coordinates = \"Mesh2_face_x Mesh2_face_y\" ; // optional attribute Mesh2:face_edge_connectivity = \"Mesh2_face_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_face_connectivity = \"Mesh2_face_links\" ; // optional attribute Mesh2:edge_face_connectivity = \"Mesh2_edge_face_links\" ; // optional attribute (requires edge_node_connectivity) integer Mesh2_face_nodes(nMesh2_face, Three) ; Mesh2_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh2_face_nodes:long_name = \"Maps every triangular face to its three corner nodes.\" ; Mesh2_face_nodes:start_index = 1 ; integer Mesh2_edge_nodes(nMesh2_edge, Two) ; Mesh2_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh2_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh2_edge_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, Three) ; Mesh2_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh2_face_edges:long_name = \"Maps every triangular face to its three edges.\" ; Mesh2_face_edges:start_index = 1 ; integer Mesh2_face_links(nMesh2_face, Three) ; Mesh2_face_links:cf_role = \"face_face_connectivity\" ; Mesh2_face_links:long_name = \"neighbor faces for faces\" ; Mesh2_face_links:start_index = 1 ; Mesh2_face_links:_FillValue = -999 ; Mesh2_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; integer Mesh2_edge_face_links(nMesh2_edge, Two) ; Mesh2_edge_face_links:cf_role = \"edge_face_connectivity\" ; Mesh2_edge_face_links:long_name = \"neighbor faces for edges\" ; Mesh2_edge_face_links:start_index = 1 ; Mesh2_edge_face_links:_FillValue = -999 ; Mesh2_edge_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_x:units = \"degrees_east\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_y:units = \"degrees_north\" ; double Mesh2_edge_x(nMesh2_edge) ; Mesh2_edge_x:standard_name = \"longitude\" ; Mesh2_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_x:units = \"degrees_east\" ; double Mesh2_edge_y(nMesh2_edge) ; Mesh2_edge_y:standard_name = \"latitude\" ; Mesh2_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_y:units = \"degrees_north\" ;","title":"2D triangular mesh topology"},{"location":"#2d-flexible-mesh-mixed-triangles-quadrilaterals-etc-topology","text":"The case of a 2D mesh with mixed face sizes is identical to the 2D triangular mesh discussed above with the exception that not all faces have the same number of nodes. To support this variability we may use in the future a ragged array, but here we propose to use _FillValue to indicate faces with smaller number of nodes than the arrays allow. The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh2\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 2 node_coordinates face_node_connectivity Optionally required attributes * face_dimension edge_node_connectivity edge_dimension Optional attributes face_edge_connectivity face_face_connectivity edge_face_connectivity boundary_node_connectivity face_coordinates edge_coordinates *The \u201cOptionally required\u201d attribute edge_node_connectivity is required only if you want to store data on the edges (i.e. if you mind the numbering order of the edges). *The \u201cOptionally required\u201d attributes face_dimension and edge_dimension are required only if the dimension ordering is nonstandard in any of the connectivity variables for faces and edges, respectively. The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a 2-dimensional mesh this should be 2. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, and optional elevation or other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute face_node_connectivity points to an index variable identifying for every face the indices of its corner nodes. The corner nodes should be specified in anticlockwise direction as viewed from above (consistent with the CF-convention for bounds of p-sided cells). The connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace; if a face has less corner nodes than MaxNumNodesPerFace then the last node indices shall be equal to _FillValue (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh2_face_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. See this section on zero or one-based indexing for more details. The face_dimension attribute specifies which netcdf dimension is used to indicate the index of the face in the connectivity arrays. This is needed because some applications store the data with the fastest varying index first, and some with that index last. The default is to use the num_faces as fastest dimension; e.g. a (num_faces, 4) array for quads, but some applications might use a (4, num_faces) order, in which case the face_dimension attribute is required to help the client code disambiguate. The edge_dimension attribute is similar for the edge connectivity arrays. In case you want to define variables on the edges of the 2D mesh topology you need to specify the edge_node_connectivity attribute to map edges to nodes. Although the face to node mapping implicitly also defines the location of the edges, it does not specify the global numbering of the edges. Again the indexing convention of edge_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_edge_nodes in the example below) and 0-based indexing is the default. Since it does not apply to edges globally, specifying the boundary_node_connectivity attribute described below does not (in and of itself) necessitate the need to specify the edge_node_connectivity attribute too. Optionally the topology may have the following attributes: * face_edge_connectivity pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to _FillValue , and the indexing convention of face_edge_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_face_edges in the example below) and 0-based indexing is the default. * face_face_connectivity pointing to an index variable identifying all faces that share an edge with each face, i.e. are neighbors. This connectivity array will thus be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last face (column) indices shall be equal to _FillValue , and the indexing convention of face_face_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. Missing neighbor faces are also expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_face_links below. * edge_face_connectivity pointing to an index variable identifying all faces that share the same edge, i. e. are neighbors to an edge. This connectivity array is thus a matrix of size nEdges x 2. It is intended to be used in combination with data defined on edges. The start_index attribute should be used to specify the indexing convention and 0-based indexing is the default. Attribute _FillValue must be present. Missing neighbor faces are expressed using _FillValue, e.g for edges at the boundary with only one neighbor face present. For details see definition of variable Mesh2_edge_face_links below. * boundary_node_connectivity pointing to an nBoundaryEdges X 2 index variable identifying for every edge of each boundary the two nodes that it connects. Again the indexing convention of boundary_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh2_boundary_nodes) and 0-based indexing is the default. Although constructed of edges, boundaries represent a different quantity than general edge data and thus the boundary_node_connectivity attribute may be specified independent of edge_node_connectivity . Information about the nature of each boundary edge (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryEdges X 1. * face_coordinates and/or edge_coordinates pointing to the auxiliary coordinate variables associated with the characteristic location of the faces and edges. These auxiliary coordinate variables will have length nFaces and nEdges respectively, and may have in turn a bounds attribute that specifies the bounding coordinates of the face or edge (thereby duplicating the data in the node_coordinates variables). The use of _FillValue to indicate faces with fewer nodes than MaxNumNodesPerFace extends to the coordinate bounds variables; this is an extension of the current convention. Example: dimensions: nMesh2_node = 5 ; // nNodes nMesh2_edge = 6 ; // nEdges nMesh2_face = 2 ; // nFaces nMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace Two = 2 ; variables: // Mesh topology integer Mesh2 ; Mesh2:cf_role = \"mesh_topology\" ; Mesh2:long_name = \"Topology data of 2D unstructured mesh\" ; Mesh2:topology_dimension = 2 ; Mesh2:node_coordinates = \"Mesh2_node_x Mesh2_node_y\" ; Mesh2:face_node_connectivity = \"Mesh2_face_nodes\" ; Mesh2:face_dimension = \"nMesh2_face\" ; Mesh2:edge_node_connectivity = \"Mesh2_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh2:edge_dimension = \"nMesh2_edge\" ; Mesh2:edge_coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_coordinates = \"Mesh2_face_x Mesh2_face_y\" ; // optional attribute Mesh2:face_edge_connectivity = \"Mesh2_face_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_face_connectivity = \"Mesh2_face_links\" ; // optional attribute Mesh2:edge_face_connectivity = \"Mesh2_edge_face_links\" ; // optional attribute (requires edge_node_connectivity) integer Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh2_face_nodes:long_name = \"Maps every face to its corner nodes.\" ; Mesh2_face_nodes:_FillValue = 999999 ; Mesh2_face_nodes:start_index = 1 ; integer Mesh2_edge_nodes(nMesh2_edge, Two) ; Mesh2_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh2_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh2_edge_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh2_face_edges:long_name = \"Maps every face to its edges.\" ; Mesh2_face_edges:_FillValue = 999999 ; Mesh2_face_edges:start_index = 1 ; integer Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_links:cf_role = \"face_face_connectivity\" ; Mesh2_face_links:long_name = \"neighbor faces for faces\" ; Mesh2_face_links:start_index = 1 ; Mesh2_face_links:_FillValue = -999 ; Mesh2_face_links:comment = \"missing edges as well as missing neighbor faces are indicated using _FillValue\" ; integer Mesh2_edge_face_links(nMesh2_edge, Two) ; Mesh2_edge_face_links:cf_role = \"edge_face_connectivity\" ; Mesh2_edge_face_links:long_name = \"neighbor faces for edges\" ; Mesh2_edge_face_links:start_index = 1 ; Mesh2_edge_face_links:_FillValue = -999 ; Mesh2_edge_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh face.\" ; Mesh2_face_x:units = \"degrees_east\" ; Mesh2_face_x:bounds = \"Mesh2_face_xbnds\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh face.\" ; Mesh2_face_y:units = \"degrees_north\" ; Mesh2_face_y:bounds = \"Mesh2_face_ybnds\" ; double Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_xbnds:standard_name = \"longitude\" ; Mesh2_face_xbnds:long_name = \"Longitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_xbnds:units = \"degrees_east\" ; Mesh2_face_xbnds:_FillValue = 9.9692099683868690E36; double Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_ybnds:standard_name = \"latitude\" ; Mesh2_face_ybnds:long_name = \"Latitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_ybnds:units = \"degrees_north\" ; Mesh2_face_ybnds:_FillValue = 9.9692099683868690E36; double Mesh2_edge_x(nMesh2_edge) ; Mesh2_edge_x:standard_name = \"longitude\" ; Mesh2_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_x:units = \"degrees_east\" ; double Mesh2_edge_y(nMesh2_edge) ; Mesh2_edge_y:standard_name = \"latitude\" ; Mesh2_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_y:units = \"degrees_north\" ; // bounds variables for edges skipped","title":"2D flexible mesh (mixed triangles, quadrilaterals, etc.) topology"},{"location":"#3d-layered-mesh-topology","text":"For a 3D layered unstructured mesh topology this proposal follows the approach of the existing CF-conventions for structured meshes: horizontal and vertical dimensions are treated separately. For the horizontal plane a 2D unstructured mesh topology is defined, which is extruded in the vertical direction by means of a vertical coordinate . The example below matches the example in the previous section combined with a vertical coordinate according CF-conventions. This example introduces also the attributes mesh and location on the 2D variables \u201cMesh2_surface\u201d and \u201cMesh2_depth\u201d. For more information about these attributes see the data definition section below. Example: dimensions: nMesh2_node = 6 ; // nNodes nMesh2_edge = 7 ; // nEdges nMesh2_face = 2 ; // nFaces nMaxMesh2_face_nodes = 4 ; // MaxNumNodesPerFace Mesh2_layers = 10 ; Two = 2 ; variables: // Mesh topology integer Mesh2 ; Mesh2:cf_role = \"mesh_topology\" ; Mesh2:long_name = \"Topology data of 2D unstructured mesh\" ; Mesh2:topology_dimension = 2 ; Mesh2:node_coordinates = \"Mesh2_node_x Mesh2_node_y\" ; Mesh2:face_node_connectivity = \"Mesh2_face_nodes\" ; Mesh2:face_dimension = \"nMesh2_face\" ; Mesh2:edge_node_connectivity = \"Mesh2_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh2:edge_dimension = \"nMesh2_edge\" ; Mesh2:edge_coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_coordinates = \"Mesh2_face_x Mesh2_face_y\" ; // optional attribute Mesh2:face_edge_connectivity = \"Mesh2_face_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh2:face_face_connectivity = \"Mesh2_face_links\" ; // optional attribute Mesh2:edge_face_connectivity = \"Mesh2_edge_face_links\" ; // optional attribute (requires edge_node_connectivity) integer Mesh2_face_nodes(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh2_face_nodes:long_name = \"Maps every face to its corner nodes.\" ; Mesh2_face_nodes:_FillValue = 999999 ; Mesh2_face_nodes:start_index = 1 ; integer Mesh2_edge_nodes(nMesh2_edge, Two) ; Mesh2_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh2_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh2_edge_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh2_face_edges:long_name = \"Maps every face to its edges.\" ; Mesh2_face_edges:_FillValue = 999999 ; Mesh2_face_edges:start_index = 1 ; integer Mesh2_face_links(nMesh2_face, nMaxMesh2_face_nodes) ; Mesh2_face_links:cf_role = \"face_face_connectivity\" ; Mesh2_face_links:long_name = \"neighbor faces for faces\" ; Mesh2_face_links:start_index = 1 ; Mesh2_face_links:_FillValue = -999 ; Mesh2_face_links:comment = \"missing edges as well as missing neighbor faces are indicated using _FillValue\" ; integer Mesh2_edge_face_links(nMesh2_edge, Two) ; Mesh2_edge_face_links:cf_role = \"edge_face_connectivity\" ; Mesh2_edge_face_links:long_name = \"neighbor faces for edges\" ; Mesh2_edge_face_links:start_index = 1 ; Mesh2_edge_face_links:_FillValue = -999 ; Mesh2_edge_face_links:comment = \"missing neighbor faces are indicated using _FillValue\" ; // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh face.\" ; Mesh2_face_x:units = \"degrees_east\" ; Mesh2_face_x:bounds = \"Mesh2_face_xbnds\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh face.\" ; Mesh2_face_y:units = \"degrees_north\" ; Mesh2_face_y:bounds = \"Mesh2_face_ybnds\" ; double Mesh2_face_xbnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_xbnds:standard_name = \"longitude\" ; Mesh2_face_xbnds:long_name = \"Longitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_xbnds:units = \"degrees_east\" ; Mesh2_face_xbnds:_FillValue = 9.9692099683868690E36; double Mesh2_face_ybnds(nMesh2_face,nMaxMesh2_face_nodes) ; Mesh2_face_ybnds:standard_name = \"latitude\" ; Mesh2_face_ybnds:long_name = \"Latitude bounds of 2D mesh face (i.e. corner coordinates).\" ; Mesh2_face_ybnds:units = \"degrees_north\" ; Mesh2_face_ybnds:_FillValue = 9.9692099683868690E36; double Mesh2_edge_x(nMesh2_edge) ; Mesh2_edge_x:standard_name = \"longitude\" ; Mesh2_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_x:units = \"degrees_east\" ; double Mesh2_edge_y(nMesh2_edge) ; Mesh2_edge_y:standard_name = \"latitude\" ; Mesh2_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh2_edge_y:units = \"degrees_north\" ; // bounds variables for edges skipped // Vertical coordinate double Mesh2_layers(Mesh2_layers) ; Mesh2_layers:standard_name = \"ocean_sigma_coordinate\" ; Mesh2_layers:long_name = \"sigma at layer midpoints\" ; Mesh2_layers:positive = \"up\" ; Mesh2_layers:formula_terms = \"sigma: Mesh2_layers eta: Mesh2_surface depth: Mesh2_depth\" ; double Mesh2_depth(nMesh2_node) ; Mesh2_depth:standard_name = \"sea_floor_depth_below_geoid\" ; Mesh2_depth:units = \"m\" ; Mesh2_depth:positive = \"down\" ; Mesh2_depth:mesh = \"Mesh2\" Mesh2_depth:location = \"node\" ; Mesh2_depth:coordinates = \"Mesh2_node_x Mesh2_node_y\" ; double Mesh2_surface(nMesh2_node) ; Mesh2_surface:standard_name = \"sea_surface_height_above_geoid\" ; Mesh2_surface:units = \"m\" ; Mesh2_surface:mesh = \"Mesh2\" Mesh2_surface:location = \"face\" ; Mesh2_surface:coordinates = \"Mesh2_face_x Mesh2_face_y\" ;","title":"3D layered mesh topology"},{"location":"#fully-3d-unstructured-ie-non-layered-mesh-topology","text":"For a fully 3D unstructured mesh topology we extend the hierarchy of nodes, edges and faces to volumes. Contrary to layered case this type of mesh requires a fully 3D specification of the mesh; hence we not only need latitude and longitude coordinates but also some kind of elevation coordinate ( this probably requires a new standard name ). The topology information is stored as attributes to a dummy variable (in the example below called \u201cMesh3D\u201d) with cf_role mesh_topology. Required topology attributes Value cf_role mesh_topology topology_dimension 3 node_coordinates volume_node_connectivity volume_shape_type Optionally-required attributes * volume_dimension face_node_connectivity face_dimension edge_node_connectivity edge_dimension Optional attributes volume_edge_connectivity volume_face_connectivity volume_volume_connectivity face_edge_connectivity boundary_node_connectivity volume_coordinates face_coordinates edge_coordinates *The \u201cOptionally required\u201d attributes edge_node_connectivity and face_node_connectivity are required only if you want to store data on the edges or faces respectively (i.e. if you mind the numbering order of the edges/faces). *The \u201cOptionally required\u201d attributes volume_dimension , face_dimension and edge_dimension are required only if the dimension ordering is nonstandard in any of the connectivity variables for volumes, faces and nodes, respectively. The attribute topology_dimension indicates the highest dimensionality of the geometric elements; for a fully 3-dimensional unstructured mesh this should be 3. The attribute node_coordinates points to the auxiliary coordinate variables representing the node locations (latitude, longitude, or other spatial coordinates, elevation and optional other coordinates). These auxiliary coordinate variables will have length nNodes. The attribute volume_node_connectivity points to an index variable identifying for every volume the indices of its corner nodes. For faces in the horizontal plane, it was possible to prescribe the order of the nodes, but this is not possible for the nodes of generic 3D volumes. For this reason we introduce an additional attribute volume_shape_type which points to a flag variable that specifies for every volume its shape: flag_meaning name description tetrahedron pyramid with triangular base, 4 nodes pyramid pyramid with square base, a pentahedron, 5 nodes wedge prism with triangular base, a pentahedron, 6 nodes hexahedron distorted cube, 8 nodes These four volume shapes are the ones most commonly used. More shapes can be added; and if necessary, it\u2019s possible to add a generic shape type which allows for specification of the volume shape indirectly via volume_face_connectivity and face_node_connectivity variables. Such a generic shape is not included in this proposal since there is no practical need for such feature at this time. If all volumes have the same shape type, then the shape type could be determined based on the number of nodes per volume. Another option could be to allow the volume_shape_type to specify the shape type directly rather than pointing to a variable. However, for the time being we assume that the currently proposed volume shape type variable doesn\u2019t have too much impact on the performance. The order in which the corner nodes of a volume are specified is fixed given its shape; this approach is common in 3D modeling, see e.g. this graph in the OpenFOAM documentation and ParaView or VTK documentation. The volume_node_connectivity array will be a matrix of size nVolumes x MaxNumNodesPerVolume; if a volume has fewer corner nodes than MaxNumNodesPerVolume then the last node indices shall be equal to _FillValue (which should obviously be larger than the number of nodes in the mesh). For the indexing one may use either 0- or 1-based indexing; the convention used should be specified using a start_index attribute to the index variable (i.e. Mesh3D_vol_nodes in the example below). Consistent with the CF-conventions compression option, the connectivity indices are 0-based by default. See this section on zero or one-based indexing for more details. The volume_dimension attribute specifies which netcdf dimension is used to indicate the index of the volume in the connectivity arrays. This is needed because some applications store the data with the fastest varying index first, and some with that index last. The default is to use the num_volumes as fastest dimension; e.g. a (num_volumes, 4) array for tetrahedrons, but some applications might use a (4, num_volumes) order, in which case the volume_dimension attribute is required to help the client code disambiguate. The face_dimension and edge_dimension attributes are similar for the face and edge connectivity arrays. In case you want to define variables on the faces or edges of the 3D mesh topology you need to specify the face_node_connectivity or edge_node_connectivity attribute, respectively, to map faces or edges to nodes. Although the volume to node mapping implicitly also defines the location of the faces and edges, it does not specify their global numbering. Again the indexing convention of face_node_connectivity and edge_node_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. Since it does not apply to either nodes or edges globally, specifying the boundary_node_connectivity attribute described below does not (in and of itself) necessitate the need to specify edge_node_connectivity nor face_node_connectivity . Optionally the topology may have the following attributes: volume_face_connectivity pointing to an index variable identifying for every volume the indices of its faces. The order in which the face indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumFacesPerVolume. If a volume has fewer faces than MaxNumFacesPerVolume then the last face indices shall be equal to _FillValue , and the indexing convention of volume_edge_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. volume_edge_connectivity pointing to an index variable identifying for every volume the indices of its edges. The order in which the edge indices should be specified is determined by the volume geometry type. This connectivity array will be a matrix of size nVolumes x MaxNumEdgesPerVolume. Again, if a volume has fewer edges than MaxNumEdgesPerVolume then the last edge indices shall be equal to _FillValue , and the indexing convention of volume_edge_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. volume_volume_connectivity pointing to an index variable identifying all volumes that share a face with each volume, i.e. are neighbors. This connectivity array will thus be a matrix of size nVolumes x MaxNumFacesPerVolume with a flag to note if the region \u201cout of mesh\u201d abuts a face of a given volume. Again, if a volume has fewer sides/faces than MaxNumFacesPerVolume then the last volume (column) indices shall be equal to _FillValue , and the indexing convention of volume_volume_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh3D_vol_links in the example below) and 0-based indexing is the default. face_edge_connectivity pointing to an index variable identifying for every face the indices of its edges. The edges should be specified in anticlockwise direction as viewed from above. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. As always, if a face has fewer corners/edges than MaxNumNodesPerFace then the last edge indices shall be equal to _FillValue , and the indexing convention of face_edge_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. face_node_connectivity pointing to an index variable identifying for every face the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to _FillValue , and the indexing convention of face_node_connectivity should be specified using the start_index attribute to the index variable and 0-based indexing is the default. boundary_node_connectivity pointing to an index variable identifying for every face of each boundary the indices of its nodes. The nodes should be specified in either clockwise or anticlockwise order. This connectivity array will be a matrix of size nBoundaryFaces x MaxNumNodesPerFace. Again, if a face has fewer corners/edges than MaxNumNodesPerFace then the last node indices shall be equal to _FillValue , and the indexing convention of boundary_node_connectivity should be specified using the start_index attribute to the index variable (i.e. Mesh3D_boundary_nodes) and 0-based indexing is the default. Although constructed of faces, boundaries represent a different quantity than general face data and thus the boundary_node_connectivity attribute may be specified independent of face_node_connectivity . Information about the nature of each boundary face (e.g. open/closed, land/water, grouping, etc.) may optionally be stored in ancillary boundary-type variables of size nBoundaryFaces X 1. volume_coordinates , face_coordinates and/or edge_coordinates pointing to the auxiliary coordinate variables associated with the characteristic location of the volumes, faces and edges. These auxiliary coordinate variables will have length nVolumes, nFaces and nEdges respectively, and may have in turn a bounds attribute that specifies the corner coordinates of the volume, face or edge (thereby duplicating the data in the node_coordinates variables). The order in which the corner coordinates of the volumes is given by the volume geometry type. Example: dimensions: nMesh3D_node = 12 ; // nNodes nMesh3D_edge = 23 ; // nEdges nMesh3D_face = 16 ; // nFaces nMesh3D_vol = 4 ; // nVolumes nMaxMesh3D_face_nodes = 4 ; // MaxNumNodesPerFace nMaxMesh3D_vol_nodes = 8 ; // MaxNumNodesPerVolume nMaxMesh3D_vol_edges = 12 ; // MaxNumEdgesPerVolume nMaxMesh3D_vol_faces = 6 ; // MaxNumFacesPerVolume Two = 2 ; variables: // Mesh topology integer Mesh3D ; Mesh3D:cf_role = \"mesh_topology\" ; Mesh3D:long_name = \"Topology data of 3D unstructured mesh\" ; Mesh3D:topology_dimension = 3 ; Mesh3D:node_coordinates = \"Mesh3D_node_x Mesh3D_node_y Mesh3D_node_z\" ; Mesh3D:volume_shape_type = \"Mesh3D_vol_types\" ; Mesh3D:volume_node_connectivity = \"Mesh3D_vol_nodes\" ; Mesh3D:volume_dimension = nMesh3D_vol ; Mesh3D:face_node_connectivity = \"Mesh3D_face_nodes\" ; // attribute required if variables will be defined on faces Mesh3D:face_dimension = nMesh3D_face ; Mesh3D:edge_node_connectivity = \"Mesh3D_edge_nodes\" ; // attribute required if variables will be defined on edges Mesh3D:edge_dimension = nMesh3D_edge ; Mesh3D:edge_coordinates = \"Mesh3D_edge_x Mesh3D_edge_y Mesh3D_edge_z\" ; // optional attribute (requires edge_node_connectivity) Mesh3D:face_coordinates = \"Mesh3D_face_x Mesh3D_face_y Mesh3D_face_z\" ; // optional attribute (requires face_node_connectivity) Mesh3D:volume_coordinates = \"Mesh3D_vol_x Mesh3D_vol_y Mesh3D_vol_z\" ; // optional attribute Mesh3D:volume_face_connectivity = \"Mesh3D_vol_faces\" ; // optional attribute (requires face_node_connectivity) Mesh3D:volume_edge_connectivity = \"Mesh3D_vol_edges\" ; // optional attribute (requires edge_node_connectivity) Mesh3D:face_edge_connectivity = \"Mesh3D_face_edges\" ; // optional attribute (requires face_node_connectivity and edge_node_connectivity) Mesh3D:volume_volume_connectivity = \"Mesh3D_vol_links\" ; // optional attribute integer Mesh3D_vol_types(nMesh3D_vol) ; Mesh3D_vol_types:cf_role = \"volume_shape_type\" ; Mesh3D_vol_types:long_name = \"Specifies the shape of the individual volumes.\" ; Mesh3D_vol_types:flag_range = 0b, 2b ; Mesh3D_vol_types:flag_values = 0b, 1b, 2b ; Mesh3D_vol_types:flag_meanings = \"tetrahedron wedge hexahedron\" ; integer Mesh3D_vol_nodes(nMesh3D_vol, nMaxMesh3D_vol_nodes) ; Mesh3D_vol_nodes:cf_role = \"volume_node_connectivity\" ; Mesh3D_vol_nodes:long_name = \"Maps every volume to its corner nodes.\" ; Mesh3D_vol_nodes:_FillValue = 999999 ; Mesh3D_vol_nodes:start_index = 1 ; // Optional mesh topology variables integer Mesh3D_edge_nodes(nMesh3D_edge, Two) ; Mesh3D_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh3D_edge_nodes:long_name = \"Maps every edge to the two nodes that it connects.\" ; Mesh3D_edge_nodes:start_index = 1 ; integer Mesh3D_face_nodes(nMesh3D_face, nMaxMesh3D_face_nodes) ; Mesh3D_face_nodes:cf_role = \"face_node_connectivity\" ; Mesh3D_face_nodes:long_name = \"Maps every face to its corner nodes.\" ; Mesh3D_face_nodes:_FillValue = 999999 ; Mesh3D_face_nodes:start_index = 1 ; integer Mesh3D_vol_faces(nMesh3D_vol, nMaxMesh3D_vol_faces) ; Mesh3D_vol_faces:cf_role = \"volume_face_connectivity\" ; Mesh3D_vol_faces:long_name = \"Maps every volume to its faces.\" ; Mesh3D_vol_faces:_FillValue = 999999 ; Mesh3D_vol_faces:start_index = 1 ; integer Mesh3D_vol_edges(nMesh3D_vol, nMaxMesh3D_vol_edges) ; Mesh3D_vol_edges:cf_role = \"volume_edge_connectivity\" ; Mesh3D_vol_edges:long_name = \"Maps every volume to its edges.\" ; Mesh3D_vol_edges:_FillValue = 999999 ; Mesh3D_vol_edges:start_index = 1 ; integer Mesh3D_face_edges(nMesh3D_face, nMaxMesh3D_face_nodes) ; Mesh3D_face_edges:cf_role = \"face_edge_connectivity\" ; Mesh3D_face_edges:long_name = \"Maps every face to its edges.\" ; Mesh3D_face_edges:_FillValue = 999999 ; Mesh3D_face_edges:start_index = 1 ; integer Mesh3D_vol_links(nMesh3D_vol, nMaxMesh3D_vol_faces) ; Mesh3D_vol_links:cf_role = \"volume_volume_connectivity\" ; Mesh3D_vol_links:long_name = \"Indicates which other volumes neighbor each volume.\" ; Mesh3D_vol_links:_FillValue = 999999 ; Mesh3D_vol_links:start_index = 1 ; Mesh3D_vol_links:flag_values = -1 ; Mesh3D_vol_links:flag_meanings = \"out_of_mesh\" ; // Mesh node coordinates double Mesh3D_node_x(nMesh3D_node) ; Mesh3D_node_x:standard_name = \"longitude\" ; Mesh3D_node_x:long_name = \"Longitude of 3D mesh nodes.\" ; Mesh3D_node_x:units = \"degrees_east\" ; double Mesh3D_node_y(nMesh3D_node) ; Mesh3D_node_y:standard_name = \"latitude\" ; Mesh3D_node_y:long_name = \"Latitude of 3D mesh nodes.\" ; Mesh3D_node_y:units = \"degrees_north\" ; double Mesh3D_node_z(nMesh3D_node) ; Mesh3D_node_z:standard_name = \"elevation\" ; Mesh3D_node_z:long_name = \"Elevation of 3D mesh nodes.\" ; Mesh3D_node_z:units = \"m\" ; // Optional mesh volume, face and edge coordinate variables double Mesh3D_vol_x(nMesh3D_vol) ; Mesh3D_vol_x:standard_name = \"longitude\" ; Mesh3D_vol_x:long_name = \"Characteristics longitude of mesh volumes.\" ; Mesh3D_vol_x:units = \"degrees_east\" ; Mesh3D_vol_x:bounds = \"Mesh3D_vol_xbnds\" ; double Mesh3D_vol_y(nMesh3D_vol) ; Mesh3D_vol_y:standard_name = \"latitude\" ; Mesh3D_vol_y:long_name = \"Characteristics latitude of mesh volumes.\" ; Mesh3D_vol_y:units = \"degrees_north\" ; Mesh3D_vol_y:bounds = \"Mesh3D_vol_ybnds\" ; double Mesh3D_vol_z(nMesh3D_vol) ; Mesh3D_vol_z:standard_name = \"elevation\" ; Mesh3D_vol_z:long_name = \"Characteristics elevation of mesh volumes.\" ; Mesh3D_vol_z:units = \"m\" ; Mesh3D_vol_z:bounds = \"Mesh3D_vol_zbnds\" ; double Mesh3D_vol_xbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ; Mesh3D_vol_xbnds:standard_name = \"longitude\" ; Mesh3D_vol_xbnds:long_name = \"Longitude bounds of mesh volumes (i.e. corner coordinates).\" ; Mesh3D_vol_xbnds:units = \"degrees_east\" ; Mesh3D_vol_xbnds:_FillValue = 9.9692099683868690E36; double Mesh3D_vol_ybnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ; Mesh3D_vol_ybnds:standard_name = \"latitude\" ; Mesh3D_vol_ybnds:long_name = \"Latitude bounds of mesh volumes (i.e. corner coordinates).\" ; Mesh3D_vol_ybnds:units = \"degrees_north\" ; Mesh3D_vol_ybnds:_FillValue = 9.9692099683868690E36; double Mesh3D_vol_zbnds(nMesh3D_vol,nMaxMesh3D_vol_nodes) ; Mesh3D_vol_zbnds:standard_name = \"elevation\" ; Mesh3D_vol_zbnds:long_name = \"Elevation bounds of mesh volumes (i.e. corner coordinates).\" ; Mesh3D_vol_zbnds:units = \"m\" ; Mesh3D_vol_zbnds:_FillValue = 9.9692099683868690E36; double Mesh3D_face_x(nMesh3D_face) ; Mesh3D_face_x:standard_name = \"longitude\" ; Mesh3D_face_x:long_name = \"Characteristics longitude of mesh faces.\" ; Mesh3D_face_x:units = \"degrees_east\" ; double Mesh3D_face_y(nMesh3D_face) ; Mesh3D_face_y:standard_name = \"latitude\" ; Mesh3D_face_y:long_name = \"Characteristics latitude of mesh faces.\" ; Mesh3D_face_y:units = \"degrees_north\" ; double Mesh3D_face_z(nMesh3D_face) ; Mesh3D_face_z:standard_name = \"elevation\" ; Mesh3D_face_z:long_name = \"Characteristics elevation of mesh faces.\" ; Mesh3D_face_z:units = \"m\" ; // bounds variables for faces skipped double Mesh3D_edge_x(nMesh3D_edge) ; Mesh3D_edge_x:standard_name = \"longitude\" ; Mesh3D_edge_x:long_name = \"Characteristic longitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh3D_edge_x:units = \"degrees_east\" ; double Mesh3D_edge_y(nMesh3D_edge) ; Mesh3D_edge_y:standard_name = \"latitude\" ; Mesh3D_edge_y:long_name = \"Characteristic latitude of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh3D_edge_y:units = \"degrees_north\" ; double Mesh3D_edge_z(nMesh3D_edge) ; Mesh3D_edge_z:standard_name = \"elevation\" ; Mesh3D_edge_z:long_name = \"Characteristic elevation of 2D mesh edge (e.g. midpoint of the edge).\" ; Mesh3D_edge_z:units = \"m\" ; // bounds variables for edges skipped","title":"Fully 3D unstructured (i.e. non-layered) mesh topology"},{"location":"#data-defined-on-unstructured-meshes","text":"According to CF-conventions a variable defined on a structured mesh is specified as double waterlevel(time,nmax,mmax) ; waterlevel:standard_name = \"sea_surface_height_above_geoid\" ; waterlevel:units = \"m\" ; waterlevel:coordinates = \"lat lon\" ; The coordinates attribute refers to the variables that contain the latitude and longitude coordinates. For a curvilinear grid these variables will share two spatial dimensions, here nmax and mmax : lat(nmax,mmax) and lon(nmax,mmax). In numerical models the various quantities are often computed at different locations of the mesh: staggered data. The standard CF-conventions don\u2019t offer specific support for this functionality and thus for every stagger location coordinates need to be provided separately: cell center coordinates, corner point coordinates, u-flux point coordinates, and v-flux point coordinates. The underlying topology of the mesh, i.e. how these coordinates (variable definition locations) relate to each other isn\u2019t stored in the file. This shortcoming is to some degree solved by the gridspec proposal by Venkatramani Balaji and Zhi Liang. We introduce here attributes that link to the topological data defined above.","title":"Data defined on unstructured meshes"},{"location":"#data-variables","text":"The use of the coordinates attribute is copied from the CF-conventions. It is used to map the values of variables defined on the unstructured meshes directly to their location: latitude, longitude, or other spatial coordinates, and optional elevation. To map the variable onto the topology of the underlying mesh, two new attributes have been introduced. First, the attribute mesh points to the mesh_topology variable containing the meta-data attributes of the mesh on which the variable has been defined. Second, the attribute location points to the (stagger) location within the mesh at which the variable is defined. Note that in this example the coordinates attribute is redundant since the coordinates could also be obtained by using the face_coordinates attribute of the \u201cMesh2\u201d variable. double Mesh2_waterlevel(time,nMesh2_face) ; Mesh2_waterlevel:standard_name = \"sea_surface_height_above_geoid\" ; Mesh2_waterlevel:units = \"m\" ; Mesh2_waterlevel:mesh = \"Mesh2\" Mesh2_waterlevel:location = \"face\" ; Mesh2_waterlevel:coordinates = \"Mesh2_face_x Mesh2_face_y\" ; The order of dimensions on a data variable is arbitrary, so nTimeSteps x nLayers x nFaces, nTimeSteps x nFaces x nLayers, nFaces x nLayers x nTimeSeps, etc would all be valid. In line with CF/COARDS and OGC NetCDF-CF we recommend to use the T,Z,Y,X [c order notation] order as much as possible where the unstructured horizontal dimension should be read for Y,X. That is, the order nTimeSteps x nLayers x nFaces [c order notation] is recommended: the nFaces is the fastest increasing dimension, then the nLayers, and finally the nTimeSteps.","title":"Data variables"},{"location":"#volume-and-flux-variables","text":"The same mesh geometry can be used in different ways to schematize the hydrodynamic volumes and fluxes. Let\u2019s take a simple triangular mesh. From a finite volume point of view this mesh will generally be interpreted as consisting of two volumes with triangular base. However, others may use a continuous Galerkin finite element method that can be shown to be equivalent to a subdivision into four volumes. In the former case the two faces correspond to volumes and the fluxes cross the edges. In the latter case the volumes are defined surrounding the four nodes and the fluxes are directed along the edges. The two abbreviated \u201cncdumps\u201d below show how the basic 2D triangular mesh definition can be extended to include this data. The coordinate variables for the volume data now include bounds attributes to define the surface area of the volumes. Note the subtle difference in the long names between the flux variables in the two cases; the standard_name attribute has to make a more formal distinction between the two cases. Variant 1: Volume at faces: dimensions: nMesh2_node = 4 ; // nNodes nMesh2_edge = 5 ; // nEdges nMesh2_face = 2 ; // nFaces Two = 2 ; Three = 3 ; variables: // Mesh topology integer Mesh2 ; // as in 2D triangular mesh example integer Mesh2_face_nodes(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_edge_nodes(nMesh2_edge, Two) ; // as in 2D triangular mesh example // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_face_links(nMesh2_face, Three) ; // as in 2D triangular mesh example // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; // as in 2D triangular mesh example double Mesh2_node_y(nMesh2_node) ; // as in 2D triangular mesh example // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; Mesh2_face_x:standard_name = \"longitude\" ; Mesh2_face_x:long_name = \"Characteristics longitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_x:units = \"degrees_east\" ; Mesh2_face_x:bounds = \"Mesh2_face_xbnds\" ; double Mesh2_face_y(nMesh2_face) ; Mesh2_face_y:standard_name = \"latitude\" ; Mesh2_face_y:long_name = \"Characteristics latitude of 2D mesh triangle (e.g. circumcenter coordinate).\" ; Mesh2_face_y:units = \"degrees_north\" ; Mesh2_face_y:bounds = \"Mesh2_face_ybnds\" ; double Mesh2_face_xbnds(nMesh2_face,Three) ; Mesh2_face_xbnds:standard_name = \"longitude\" ; Mesh2_face_xbnds:long_name = \"Longitude bounds of 2D mesh triangle (i.e. corner coordinates).\" ; Mesh2_face_xbnds:units = \"degrees_east\" ; double Mesh2_face_ybnds(nMesh2_face,Three) ; Mesh2_face_ybnds:standard_name = \"latitude\" ; Mesh2_face_ybnds:long_name = \"Latitude bounds of 2D mesh triangle (i.e. corner coordinates).\" ; Mesh2_face_ybnds:units = \"degrees_north\" ; double Mesh2_edge_x(nMesh2_edge) ; // as in 2D triangular mesh example double Mesh2_edge_y(nMesh2_edge) ; // as in 2D triangular mesh example // Volume and flux data double Mesh2_volumes(nMesh2_face) ; Mesh2_volumes:long_name = \"volumes\" ; Mesh2_volumes:units = \"m3\" ; Mesh2_volumes:mesh = \"Mesh2\" ; Mesh2_volumes:location = \"face\" ; Mesh2_volumes:coordinates = \"Mesh2_face_x Mesh2_face_y\" ; double Mesh2_fluxes(nMesh2_edge) ; Mesh2_fluxes:long_name = \"flux across edge\" ; Mesh2_fluxes:units = \"m3 s-1\" ; Mesh2_fluxes:mesh = \"Mesh2\" Mesh2_fluxes:location = \"edge\" ; Mesh2_fluxes:coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ; Variant 2: Volume at nodes: dimensions: nMesh2_node = 4 ; // nNodes nMesh2_edge = 5 ; // nEdges nMesh2_face = 2 ; // nFaces nMaxMesh2_bnds = 6 ; Two = 2 ; Three = 3 ; variables: // Mesh topology integer Mesh2 ; // as in 2D triangular mesh example integer Mesh2_face_nodes(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_edge_nodes(nMesh2_edge, Two) ; // as in 2D triangular mesh example // Optional mesh topology variables integer Mesh2_face_edges(nMesh2_face, Three) ; // as in 2D triangular mesh example integer Mesh2_face_links(nMesh2_face, Three) ; // as in 2D triangular mesh example // Mesh node coordinates double Mesh2_node_x(nMesh2_node) ; Mesh2_node_x:standard_name = \"longitude\" ; Mesh2_node_x:long_name = \"Longitude of 2D mesh nodes.\" ; Mesh2_node_x:units = \"degrees_east\" ; Mesh2_node_x:bounds = \"Mesh2_node_xbnds\" ; double Mesh2_node_y(nMesh2_node) ; Mesh2_node_y:standard_name = \"latitude\" ; Mesh2_node_y:long_name = \"Latitude of 2D mesh nodes.\" ; Mesh2_node_y:units = \"degrees_north\" ; Mesh2_node_y:bounds = \"Mesh2_node_ybnds\" ; double Mesh2_node_xbnds(nMesh2_node, nMaxMesh2_bnds) ; Mesh2_node_xbnds:standard_name = \"longitude\" ; Mesh2_node_xbnds:long_name = \"List of x-points that form outline of flow volume\" ; Mesh2_node_xbnds:units = \"degrees_east\" ; Mesh2_node_xbnds:_FillValue = 9.9692099683868690E36; double Mesh2_node_ybnds(nMesh2_node, nMaxMesh2_bnds) ; Mesh2_node_ybnds:standard_name = \"latitude\" ; Mesh2_node_ybnds:units = \"degrees_north\" ; Mesh2_node_ybnds:long_name = \"List of y-points that form outline of flow volume\" ; Mesh2_node_xbnds:_FillValue = 9.9692099683868690E36; // Optional mesh face and edge coordinate variables double Mesh2_face_x(nMesh2_face) ; // as in 2D triangular mesh example double Mesh2_face_y(nMesh2_face) ; // as in 2D triangular mesh example double Mesh2_edge_x(nMesh2_edge) ; // as in 2D triangular mesh example double Mesh2_edge_y(nMesh2_edge) ; // as in 2D triangular mesh example // Volume and flux data double Mesh2_volumes(nMesh2_node) ; Mesh2_volumes:long_name = \"volumes\" ; Mesh2_volumes:units = \"m3\" ; Mesh2_volumes:mesh = \"Mesh2\" ; Mesh2_volumes:location = \"node\" ; Mesh2_volumes:coordinates = \"Mesh2_node_x Mesh2_node_y\" ; double Mesh2_fluxes(nMesh2_edge) ; Mesh2_fluxes:long_name = \"flux along edge\" ; Mesh2_fluxes:units = \"m3 s-1\" ; Mesh2_fluxes:mesh = \"Mesh2\" Mesh2_fluxes:location = \"edge\" ; Mesh2_fluxes:coordinates = \"Mesh2_edge_x Mesh2_edge_y\" ;","title":"Volume and flux variables"},{"location":"#location-index-set","text":"Some variables may only be defined at specific locations within the mesh, e.g. only at boundary points or at special locations like weirs and gates. To save space and to improve readability, the concept of a location_index_set is introduced. It is basically identical to the compression option in the the CF-conventions except for the fact that the compression works on a (set of) orthogonal coordinate dimension(s) and the location_index_set works on a topology location. The location index set is an integer variable that contains the indices of the locations at which a specific quantity is defined. The example below defines a location index set \u201cMesh1_set\u201d as a subset of the \u201cnode\u201ds of Mesh1 (red points). The attribute location_index_set of the variable \u201cMesh_waterlevel\u201d points to this index set and the coordinates attribute points to the corresponding (subset) of latitude and longitude coordinates. The mesh and location attributes of the location_index_set variable are required; the coordinates attribute is optional. Note that the coordinates attributes on both \u201cMesh1_cell\u201d and \u201cMesh1_waterlevel\u201d are again redundant since the coordinates could also be obtained by using the index set \u201cMesh1_set\u201d and the node_coordinates attribute of the \u201cMesh1\u201d variable. Consistent with all other index variables defined here, the indexing convention of the location index set should be specified using the start_index attribute to the index variable and 0-based indexing is the default. See this section on zero or one-based indexing for more details. Contrary to a coordinate variable, the index set doesn\u2019t have to be monotonic. So, it can be used for creating subsets of the original locations as well as for renumbering the locations. If the location_index_set attribute is used on a variable, then the mesh and location attributes should not also be used on that variable. dimensions: nMesh1_set = 4 ; variables: integer Mesh1_set(nMesh1_set) ; Mesh1_set:cf_role = \"location_index_set\" ; Mesh1_set:long_name = \"Defines Mesh1_set as subset of the nodes of Mesh1.\" ; Mesh1_set:mesh = \"Mesh1\" ; Mesh1_set:location = \"node\" ; Mesh1_set:start_index = 1 ; Mesh1_set:coordinates = \"Mesh1_set_x Mesh1_set_y\" ; double Mesh1_set_x(nMesh1_set) ; Mesh1_set_x:standard_name = \"longitude\" ; Mesh1_set_x:long_name = \"Characteristic longitude of set (e.g. longitude of node).\" ; Mesh1_set_x:units = \"degrees_east\" ; double Mesh1_set_y(nMesh1_set) ; Mesh1_set_y:standard_name = \"latitude\" ; Mesh1_set_y:long_name = \"Characteristic latitude of set (e.g. latitude of node)\" ; Mesh1_set_y:units = \"degrees_north\" ; double Mesh1_waterlevel(time, nMesh1_set) ; Mesh1_waterlevel:standard_name = \"sea_surface_height_above_geoid\" ; Mesh1_waterlevel:units = \"m\" ; Mesh1_waterlevel:location_index_set = \"Mesh1_set\" ; Mesh1_waterlevel:coordinates = \"Mesh1_set_x Mesh1_set_y\" ;","title":"Location index set"},{"location":"#zero-or-one-based-indexing","text":"The indexing using by the CF compression option is 0-based. Therefore, it is most consistent for this CF extension for unstructured data to also use 0-based indexing, which means that points, edges, faces and volumes will be numbered starting with 0. This convention is consistent with languages like C, Java and Python, but unlike Fortran and MATLAB. Since many of the unstructured models have been programmed in Fortran and legacy NetCDF files exist that use 1-based indexing (which could be upgraded to be consistent with this new proposal using ncML if 1-based indexing were allowed), we propose to support both 0- and 1-based indexing by means of the start_index attribute. You will find below two examples of the same network geometry using either 0- or 1-based indexing. Switching between 0- and 1-based indexing is as easy as adding 1 to or subtracting 1 from the indices upon reading or writing depending on the setting of start_index ; allowing both options should only have a minor impact on the reading routines and no effect at all on the rest of your code. Example of 0-based indexing: dimensions: nMesh1_node = 5 ; // nNodes nMesh1_edge = 4 ; // nEdges Two = 2; variables: // Mesh topology integer Mesh1 ; Mesh1:cf_role = \"mesh_topology\" ; Mesh1:long_name = \"Topology data of 1D network\" ; Mesh1:topology_dimension = 1 ; Mesh1:node_coordinates = \"Mesh1_node_x Mesh1_node_y\" ; Mesh1:edge_node_connectivity = \"Mesh1_edge_nodes\" ; Mesh1:edge_coordinates = \"Mesh1_edge_x Mesh1_edge_y\" ; // optional attribute integer Mesh1_edge_nodes(nMesh1_edge, Two) ; Mesh1_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh1_edge_nodes:long_name = \"Maps every edge/link to the two nodes that it connects.\" ; Mesh1_edge_nodes:start_index = 0 ; // default setting, attribute could have been skipped. // Coordinate variables skipped data: Mesh1 = 0 ; // dummy Mesh1_edge_nodes = 0, 2, 1, 2, 2, 3, 3, 4 ; Example of 1-based indexing: dimensions: nMesh1_node = 5 ; // nNodes nMesh1_edge = 4 ; // nEdges Two = 2; variables: // Mesh topology integer Mesh1 ; Mesh1:cf_role = \"mesh_topology\" ; Mesh1:long_name = \"Topology data of 1D network\" ; Mesh1:topology_dimension = 1 ; Mesh1:node_coordinates = \"Mesh1_node_x Mesh1_node_y\" ; Mesh1:edge_node_connectivity = \"Mesh1_edge_nodes\" ; Mesh1:edge_coordinates = \"Mesh1_edge_x Mesh1_edge_y\" ; // optional attribute integer Mesh1_edge_nodes(nMesh1_edge, Two) ; Mesh1_edge_nodes:cf_role = \"edge_node_connectivity\" ; Mesh1_edge_nodes:long_name = \"Maps every edge/link to the two nodes that it connects.\" ; Mesh1_edge_nodes:start_index = 1 ; // Coordinate variables skipped data: Mesh1 = 0 ; // dummy Mesh1_edge_nodes = 1, 3, 2, 3, 3, 4, 4, 5 ;","title":"Zero or One-based indexing"},{"location":"conformance/","text":".. DRAFT .. DRAFT .. Status : First Draft Hopefully, this can evolve into an agreed final form by the time of the next UGRID release. Contributions are welcome. Conformance rules for UGRID Conventions v1.x \uf0c1 This information is intended to follow the practice established by the CF conformance pages , as attached to the CF conventions . In that spirit, this is likewise \u201cintended to be a concise summary\u201d of the main convention, and \u201cif there are any discrepancies \u2026 the conventions document is the ultimate authority.\u201d Each reference statement is provided with a short code : \u201cRxxx\u201d for requirements and \u201cAxxx\u201d for advisory recommendations, in the manner of the Flake8 error and warning codes , and the PyCodeStyle ones . Future editions will maintain these reference numbers, but possibly add new ones. They can be used as definitive references by a conformance-checker utility. 10 This version is consistent with : UGRID v1.0 CF version 1.11 Conformance rules for UGRID Conventions v1.x Preamble : Terms and Definitions Mesh variables Mesh variable requirements Mesh variable recommendations Mesh coordinate variables Mesh coordinate variable requirements Mesh coordinate variable recommendations Mesh connectivity variables Mesh connectivity variable requirements Mesh connectivity variable recommendations Location index set variables Location index set variable requirements Location index set variable recommendations Mesh data variables Mesh data variable requirements Other Other recommendations Preamble : Terms and Definitions \uf0c1 A mesh variable is a variable with a cf_role attribute of \"mesh_topology\" . 2 A varlist is a string attribute consisting of a space-separated list of variable names these must be names of variables existing in the same dataset : this is implicit in all uses A coordinate attribute of a mesh is a varlist with one of the following names 2 4 node_coordinates edge_coordinates face_coordinates A connectivity attribute of a mesh is a varlist with one of the following names 2 4 edge_node_connectivity face_node_connectivity face_edge_connectivity edge_face_connectivity face_face_connectivity boundary_node_connectivity A mesh coordinate is a variable listed in a coordinate attribute of a mesh A mesh connectivity is a variable listed in a connectivity attribute of a mesh 2 A mesh is the parent mesh of those mesh coordinates or mesh connectivities which are included in any of its coordinate or connectivity attributes : This defines the \u201cparent mesh\u201d of any mesh coordinate or mesh connectivity. 1 The parent mesh of a location index set is that named in its mesh attribute the element dimensions of a mesh are those indexing its elements (i.e. nodes, edges or faces), or mesh boundaries, within any of its mesh coordinates and mesh connectivities. the node dimension is the single dimension of the node coordinates (should all be the same) if there is an edge_node_connectivity , then there is an edge dimension (see below for how this is determined) if there is a face_node_connectivity , then there is a face dimension (see below for how this is determined) if there is a boundary_node_connectivity , then there is a boundary dimension (see below for how this is determined) the element dimension of a mesh connectivity or mesh coordinate is that one of its dimensions which is an element dimension of its parent mesh. N.B. there can only be one : see R201 / R304 A location index set is a variable with a cf_role attribute of \"location_index_set\" 2 A mesh data variable is a CF data variable with either a mesh or a location_index_set attribute. Mesh variables \uf0c1 Mesh variable requirements \uf0c1 For any mesh variable .. R101 it must have a cf_role attribute, R102 with the value \"mesh_topology\" R103 it must have a topology_dimension attribute, R104 whose value is an integer between 0 and 2. 4 5 all mesh connectivity and coordinate attributes must be varlists, that is .. R105 they are strings consisting of space-separated, valid netcdf variable names, and R106 the variables named all exist in the dataset R107 all mesh connectivity attributes must contain a single variable name R108 all elements of all mesh coordinate attributes must be valid mesh coordinates R109 all mesh connectivity attributes must be valid mesh connectivities R110 it must have a node_coordinates attribute an edge_node_connectivity attribute .. R111 must not be present, if topology_dimension is 0. 5 R112 must be present, if topology_dimension is 1. R113 a face_node_connectivity attribute must be present if and only if topology_dimension is 2 R114 a boundary_node_connectivity attribute may be present, only if topology_dimension is 2 6 if the mesh has an edge_node_connectivity , then it has an edge dimension , which either is given by the edge_dimension attribute, if there is one , in which case R115 edge_dimension must be the name of a dataset dimension or , if there is no edge_dimension attribute , the edge dimension is the first dimension of the edge_node_connectivity when an edge dimension exists .. R116 if any edge connectivity has the edge dimension as its second dimension, (instead of its first), then the mesh must have an edge_dimension attribute if the mesh has a face_node_connectivity , then it has a face dimension , which .. either is given by the face_dimension attribute, if there is one , in which case R117 face_dimension must be the name of a dataset dimension or , if there is no face_dimension attribute , the edge dimension is the first dimension of the face_node_connectivity when a face dimension exists .. R118 if any face connectivity has the face dimension as its second dimension, (instead of its first), then the mesh must have a face_dimension attribute if the mesh has a boundary_node_connectivity , then it has a boundary dimension , which is the first dimension of the boundary_node_connectivity variable 7 R119 a face_face_connectivity attribute may only exist if the mesh has a face dimension R120 a face_edge_connectivity attribute may only exist if the mesh has both a face dimension and an edge dimension R121 an edge_face_connectivity attribute may only exist if the mesh has both a face dimension and an edge dimension R122 a face_dimension attribute may only exist if the mesh has a face dimension R123 an edge_dimension attribute may only exist if the mesh has an edge dimension Mesh variable recommendations \uf0c1 A101 it should have no dimensions A102 it should not have a standard_name attribute A103 it should not have a units attribute A104 it should not share any of its element dimensions with other meshes 11 A105 if it has multiple element dimensions, they should all be different A106 it should not have any attributes ending in \u201c_connectivity\u201d, \u201c_coordinates\u201d or \u201c_dimension\u201d which are not valid UGRID terms 12 Mesh coordinate variables \uf0c1 For any mesh coordinate variable .. Mesh coordinate variable requirements \uf0c1 R201 it must map a single dimension R202 which is the appropriate element dimension of the parent mesh R203 any bounds attribute must refer to a suitable CF bounds variable matching its own properties and dimensions Mesh coordinate variable recommendations \uf0c1 A201 it should have one and only one parent mesh 1 A202 it should have a floating-point data type A203 it should have a standard_name attribute which is a valid CF standard-name (see : CF conformance section 3.3) A204 it should have a units attribute which is a valid CF unit (see CF conformance section 3.1) if it has a bounds attribute, then A205 the data values of the bounds variable should match those calculated from the relevant UGRID element coordinates and connectivities 8 A206 if its location is \u2018node\u2019, then it should not have a bounds attribute. Mesh connectivity variables \uf0c1 Mesh connectivity variable requirements \uf0c1 For any mesh connectivity variable .. R301 it must have a cf_role attribute, which R302 is a valid connectivity attribute name, and R303 matches its referring connectivity attribute in the parent mesh R304 it must exactly have two dimensions, of which R305 one is an element dimension of its parent mesh, and R306 the other is not an element dimension R307 its element dimension must be that of the first location named in its cf_role 13 R308 if it has a cf_role 13 of edge_node_connectivity or boundary_node_connectivity , then its non-element dimension must have length 2 R309 any start_index attribute must have one of the values (0, 1). R310 if it has a cf_role of edge_node_connectivity or boundary_node_connectivity , then it must not contain any \u2018missing\u2019 indices R311 if it has a cf_role of face_node_connectivity , then each face index must contain at least 3 non-\u2018missing\u2019 indices Mesh connectivity variable recommendations \uf0c1 A301 it should have one and only one parent mesh 1 A302 it should have an integer type A303 any start_index attribute should have an integer type A304 if it has a cf_role of edge_node_connectivity or boundary_node_connectivity , then it should not have a _FillValue attribute A305 if it contains any \u201cmissing\u201d indices, then it should have a _FillValue attribute : I.E. it does not rely on a netcdf \u201cdefault fill-value\u201d if there is a _FillValue attribute, then A306 it should have the same type as the connectivity variable itself, and A307 it should have a negative value A308 all its non-missing values should be valid indices into the relevant dimension of the parent mesh, i.e. the second location named in the cf_role 3 8 . Location index set variables \uf0c1 For any location index set variable .. Location index set variable requirements \uf0c1 R401 it must have a cf_role attribute with the value \"location_index_set\" R402 it must have a mesh attribute, which is a string containing the name of a valid mesh variable in the dataset R403 it must have a location attribute, which is one of face , edge or node , and R404 the corresponding location must exist in the parent mesh R405 it must have a single dimension R406 any start_index attribute must have one of the values (0, 1). Location index set variable recommendations \uf0c1 A401 it should have an integer type A402 it should not contain any missing points A403 it should not have a _FillValue attribute A404 the length of its single dimension should be less than or equal to the corresponding element dimension of its parent mesh A405 its values should all be distinct, and A406 they should all be valid indexes into the relevant element dimension of its parent mesh 3 8 A407 any start_index attribute should have an integer type Mesh data variables \uf0c1 Mesh data variable requirements \uf0c1 if there is a mesh attribute R501 there must be no location_index_set attribute R502 the mesh must be the name of a valid mesh variable in the dataset R503 there must be a location attribute, R504 which is one of face , edge or node , and R505 the corresponding dimension must exist in the parent mesh if there is a location_index_set attribute R506 there must be no mesh attribute R507 there must be no location attribute R508 the location_index_set must name a valid location index set variable in the dataset its dimensions .. R509 must contain one and only one mesh element dimension, which R510 is the appropriate element dimension of its mesh and location, as given by it\u2019s own mesh and location properties, or by those of its location_index_set Other \uf0c1 Other recommendations \uf0c1 A901 all dataset contents (dimension, variables and their attributes) should also be CF compliant \u2013 see: CF conventions . A902 there should be a global Conventions attribute, A903 which contains a string section of the form UGRID-<X.Y> , where \u201c<X.Y>\u201d is an appropriate release version of the UGRID conventions. 9 A904 no netcdf variable should have a cf_role equal to any of the values defined here, unless it is one of the UGRID variable types defined here to use one \u2013 i.e. a mesh, location index set or connectivity variable A905 no dataset variable should have a cf_role which is not either one of the valid terms described here, or one of the CF-defined cf_role values 14 From the given definitions, any mesh connectivity or -coordinate must logically have a parent mesh. We intend that it should always have exactly and only one. \u21a9 \u21a9 \u21a9 for correctness testing (only), we may broaden the definitions of these items in order to detect some obvious errors. For example, we will attempt to check as a mesh variable any variable that either has a cf_role of mesh_topology or is named in the mesh attribute of a data variable or location index set variable. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u201cvalid\u201d element indices are values within the range of the corresponding element dimension of the parent mesh, allowing for any start_index offset. \u21a9 \u21a9 For now at least, we exclude mention of full-3d meshes, whose status is currently in question : cf. this GitHub discussion , as this would add considerable complexity here. \u21a9 \u21a9 \u21a9 For now, we allow 0-d meshes (those with nodes only). Though, this is not explicitly mentioned in the UGRID v1.0 pages. \u21a9 \u21a9 It is not supported to have boundaries in a 1-D mesh (I.E. one with only edges), though this is not logically impossible. If a specific need arises, this could change in future. \u21a9 Since there is no provision for a boundary_dimension attribute, the boundary dimension is always the first dimension of a boundary_node_connectivity , and its second dimension must always be 2 (i.e. it cannot be transposed). If a specific need arises, this could change in future. \u21a9 Requirements on values of variables may not always be practical to check, since this requires loading all of their data. \u21a9 \u21a9 \u21a9 The form of the global Conventions attribute is determined by the CF conformance pages , section 2.6.1. However, the definition of UGRID release numbers is not yet finalised. \u21a9 Providing stable statement references allows conformance statements to evolve without invalidating earlier versions of a checker program. We also provide a linkable web anchor for each one. \u21a9 if a mesh does not share any element dimensions with other meshes, it follows that it also will not share any element coordinates or connectivities with other meshes. \u21a9 invalid \u2018lookalike\u2019 attributes, which are not defined by UGRID, include such as : \u201cnode_face_connectivity\u201d, \u201cboundary_coordinates\u201d, \u201cboundary_dimension\u201d or \u201cnode_dimension\u201d. \u21a9 for checking purposes, the identity of a connectivity is actually defined by the referring attribute in the parent mesh. However, if the connectivity is correctly formed, then its cf_role value will always be the same as this \u2013 cf: R303 . \u21a9 \u21a9 in the present latest CF version the only cf_role terms defined are the discrete-geometry types : timeseries_id , profile_id and trajectory_id \u21a9","title":"Conformance"},{"location":"conformance/#conformance-rules-for-ugrid-conventions-v1x","text":"This information is intended to follow the practice established by the CF conformance pages , as attached to the CF conventions . In that spirit, this is likewise \u201cintended to be a concise summary\u201d of the main convention, and \u201cif there are any discrepancies \u2026 the conventions document is the ultimate authority.\u201d Each reference statement is provided with a short code : \u201cRxxx\u201d for requirements and \u201cAxxx\u201d for advisory recommendations, in the manner of the Flake8 error and warning codes , and the PyCodeStyle ones . Future editions will maintain these reference numbers, but possibly add new ones. They can be used as definitive references by a conformance-checker utility. 10 This version is consistent with : UGRID v1.0 CF version 1.11 Conformance rules for UGRID Conventions v1.x Preamble : Terms and Definitions Mesh variables Mesh variable requirements Mesh variable recommendations Mesh coordinate variables Mesh coordinate variable requirements Mesh coordinate variable recommendations Mesh connectivity variables Mesh connectivity variable requirements Mesh connectivity variable recommendations Location index set variables Location index set variable requirements Location index set variable recommendations Mesh data variables Mesh data variable requirements Other Other recommendations","title":"Conformance rules for UGRID Conventions v1.x"},{"location":"conformance/#preamble-terms-and-definitions","text":"A mesh variable is a variable with a cf_role attribute of \"mesh_topology\" . 2 A varlist is a string attribute consisting of a space-separated list of variable names these must be names of variables existing in the same dataset : this is implicit in all uses A coordinate attribute of a mesh is a varlist with one of the following names 2 4 node_coordinates edge_coordinates face_coordinates A connectivity attribute of a mesh is a varlist with one of the following names 2 4 edge_node_connectivity face_node_connectivity face_edge_connectivity edge_face_connectivity face_face_connectivity boundary_node_connectivity A mesh coordinate is a variable listed in a coordinate attribute of a mesh A mesh connectivity is a variable listed in a connectivity attribute of a mesh 2 A mesh is the parent mesh of those mesh coordinates or mesh connectivities which are included in any of its coordinate or connectivity attributes : This defines the \u201cparent mesh\u201d of any mesh coordinate or mesh connectivity. 1 The parent mesh of a location index set is that named in its mesh attribute the element dimensions of a mesh are those indexing its elements (i.e. nodes, edges or faces), or mesh boundaries, within any of its mesh coordinates and mesh connectivities. the node dimension is the single dimension of the node coordinates (should all be the same) if there is an edge_node_connectivity , then there is an edge dimension (see below for how this is determined) if there is a face_node_connectivity , then there is a face dimension (see below for how this is determined) if there is a boundary_node_connectivity , then there is a boundary dimension (see below for how this is determined) the element dimension of a mesh connectivity or mesh coordinate is that one of its dimensions which is an element dimension of its parent mesh. N.B. there can only be one : see R201 / R304 A location index set is a variable with a cf_role attribute of \"location_index_set\" 2 A mesh data variable is a CF data variable with either a mesh or a location_index_set attribute.","title":"Preamble : Terms and Definitions"},{"location":"conformance/#mesh-variables","text":"","title":"Mesh variables"},{"location":"conformance/#mesh-variable-requirements","text":"For any mesh variable .. R101 it must have a cf_role attribute, R102 with the value \"mesh_topology\" R103 it must have a topology_dimension attribute, R104 whose value is an integer between 0 and 2. 4 5 all mesh connectivity and coordinate attributes must be varlists, that is .. R105 they are strings consisting of space-separated, valid netcdf variable names, and R106 the variables named all exist in the dataset R107 all mesh connectivity attributes must contain a single variable name R108 all elements of all mesh coordinate attributes must be valid mesh coordinates R109 all mesh connectivity attributes must be valid mesh connectivities R110 it must have a node_coordinates attribute an edge_node_connectivity attribute .. R111 must not be present, if topology_dimension is 0. 5 R112 must be present, if topology_dimension is 1. R113 a face_node_connectivity attribute must be present if and only if topology_dimension is 2 R114 a boundary_node_connectivity attribute may be present, only if topology_dimension is 2 6 if the mesh has an edge_node_connectivity , then it has an edge dimension , which either is given by the edge_dimension attribute, if there is one , in which case R115 edge_dimension must be the name of a dataset dimension or , if there is no edge_dimension attribute , the edge dimension is the first dimension of the edge_node_connectivity when an edge dimension exists .. R116 if any edge connectivity has the edge dimension as its second dimension, (instead of its first), then the mesh must have an edge_dimension attribute if the mesh has a face_node_connectivity , then it has a face dimension , which .. either is given by the face_dimension attribute, if there is one , in which case R117 face_dimension must be the name of a dataset dimension or , if there is no face_dimension attribute , the edge dimension is the first dimension of the face_node_connectivity when a face dimension exists .. R118 if any face connectivity has the face dimension as its second dimension, (instead of its first), then the mesh must have a face_dimension attribute if the mesh has a boundary_node_connectivity , then it has a boundary dimension , which is the first dimension of the boundary_node_connectivity variable 7 R119 a face_face_connectivity attribute may only exist if the mesh has a face dimension R120 a face_edge_connectivity attribute may only exist if the mesh has both a face dimension and an edge dimension R121 an edge_face_connectivity attribute may only exist if the mesh has both a face dimension and an edge dimension R122 a face_dimension attribute may only exist if the mesh has a face dimension R123 an edge_dimension attribute may only exist if the mesh has an edge dimension","title":"Mesh variable requirements"},{"location":"conformance/#mesh-variable-recommendations","text":"A101 it should have no dimensions A102 it should not have a standard_name attribute A103 it should not have a units attribute A104 it should not share any of its element dimensions with other meshes 11 A105 if it has multiple element dimensions, they should all be different A106 it should not have any attributes ending in \u201c_connectivity\u201d, \u201c_coordinates\u201d or \u201c_dimension\u201d which are not valid UGRID terms 12","title":"Mesh variable recommendations"},{"location":"conformance/#mesh-coordinate-variables","text":"For any mesh coordinate variable ..","title":"Mesh coordinate variables"},{"location":"conformance/#mesh-coordinate-variable-requirements","text":"R201 it must map a single dimension R202 which is the appropriate element dimension of the parent mesh R203 any bounds attribute must refer to a suitable CF bounds variable matching its own properties and dimensions","title":"Mesh coordinate variable requirements"},{"location":"conformance/#mesh-coordinate-variable-recommendations","text":"A201 it should have one and only one parent mesh 1 A202 it should have a floating-point data type A203 it should have a standard_name attribute which is a valid CF standard-name (see : CF conformance section 3.3) A204 it should have a units attribute which is a valid CF unit (see CF conformance section 3.1) if it has a bounds attribute, then A205 the data values of the bounds variable should match those calculated from the relevant UGRID element coordinates and connectivities 8 A206 if its location is \u2018node\u2019, then it should not have a bounds attribute.","title":"Mesh coordinate variable recommendations"},{"location":"conformance/#mesh-connectivity-variables","text":"","title":"Mesh connectivity variables"},{"location":"conformance/#mesh-connectivity-variable-requirements","text":"For any mesh connectivity variable .. R301 it must have a cf_role attribute, which R302 is a valid connectivity attribute name, and R303 matches its referring connectivity attribute in the parent mesh R304 it must exactly have two dimensions, of which R305 one is an element dimension of its parent mesh, and R306 the other is not an element dimension R307 its element dimension must be that of the first location named in its cf_role 13 R308 if it has a cf_role 13 of edge_node_connectivity or boundary_node_connectivity , then its non-element dimension must have length 2 R309 any start_index attribute must have one of the values (0, 1). R310 if it has a cf_role of edge_node_connectivity or boundary_node_connectivity , then it must not contain any \u2018missing\u2019 indices R311 if it has a cf_role of face_node_connectivity , then each face index must contain at least 3 non-\u2018missing\u2019 indices","title":"Mesh connectivity variable requirements"},{"location":"conformance/#mesh-connectivity-variable-recommendations","text":"A301 it should have one and only one parent mesh 1 A302 it should have an integer type A303 any start_index attribute should have an integer type A304 if it has a cf_role of edge_node_connectivity or boundary_node_connectivity , then it should not have a _FillValue attribute A305 if it contains any \u201cmissing\u201d indices, then it should have a _FillValue attribute : I.E. it does not rely on a netcdf \u201cdefault fill-value\u201d if there is a _FillValue attribute, then A306 it should have the same type as the connectivity variable itself, and A307 it should have a negative value A308 all its non-missing values should be valid indices into the relevant dimension of the parent mesh, i.e. the second location named in the cf_role 3 8 .","title":"Mesh connectivity variable recommendations"},{"location":"conformance/#location-index-set-variables","text":"For any location index set variable ..","title":"Location index set variables"},{"location":"conformance/#location-index-set-variable-requirements","text":"R401 it must have a cf_role attribute with the value \"location_index_set\" R402 it must have a mesh attribute, which is a string containing the name of a valid mesh variable in the dataset R403 it must have a location attribute, which is one of face , edge or node , and R404 the corresponding location must exist in the parent mesh R405 it must have a single dimension R406 any start_index attribute must have one of the values (0, 1).","title":"Location index set variable requirements"},{"location":"conformance/#location-index-set-variable-recommendations","text":"A401 it should have an integer type A402 it should not contain any missing points A403 it should not have a _FillValue attribute A404 the length of its single dimension should be less than or equal to the corresponding element dimension of its parent mesh A405 its values should all be distinct, and A406 they should all be valid indexes into the relevant element dimension of its parent mesh 3 8 A407 any start_index attribute should have an integer type","title":"Location index set variable recommendations"},{"location":"conformance/#mesh-data-variables","text":"","title":"Mesh data variables"},{"location":"conformance/#mesh-data-variable-requirements","text":"if there is a mesh attribute R501 there must be no location_index_set attribute R502 the mesh must be the name of a valid mesh variable in the dataset R503 there must be a location attribute, R504 which is one of face , edge or node , and R505 the corresponding dimension must exist in the parent mesh if there is a location_index_set attribute R506 there must be no mesh attribute R507 there must be no location attribute R508 the location_index_set must name a valid location index set variable in the dataset its dimensions .. R509 must contain one and only one mesh element dimension, which R510 is the appropriate element dimension of its mesh and location, as given by it\u2019s own mesh and location properties, or by those of its location_index_set","title":"Mesh data variable requirements"},{"location":"conformance/#other","text":"","title":"Other"},{"location":"conformance/#other-recommendations","text":"A901 all dataset contents (dimension, variables and their attributes) should also be CF compliant \u2013 see: CF conventions . A902 there should be a global Conventions attribute, A903 which contains a string section of the form UGRID-<X.Y> , where \u201c<X.Y>\u201d is an appropriate release version of the UGRID conventions. 9 A904 no netcdf variable should have a cf_role equal to any of the values defined here, unless it is one of the UGRID variable types defined here to use one \u2013 i.e. a mesh, location index set or connectivity variable A905 no dataset variable should have a cf_role which is not either one of the valid terms described here, or one of the CF-defined cf_role values 14 From the given definitions, any mesh connectivity or -coordinate must logically have a parent mesh. We intend that it should always have exactly and only one. \u21a9 \u21a9 \u21a9 for correctness testing (only), we may broaden the definitions of these items in order to detect some obvious errors. For example, we will attempt to check as a mesh variable any variable that either has a cf_role of mesh_topology or is named in the mesh attribute of a data variable or location index set variable. \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u201cvalid\u201d element indices are values within the range of the corresponding element dimension of the parent mesh, allowing for any start_index offset. \u21a9 \u21a9 For now at least, we exclude mention of full-3d meshes, whose status is currently in question : cf. this GitHub discussion , as this would add considerable complexity here. \u21a9 \u21a9 \u21a9 For now, we allow 0-d meshes (those with nodes only). Though, this is not explicitly mentioned in the UGRID v1.0 pages. \u21a9 \u21a9 It is not supported to have boundaries in a 1-D mesh (I.E. one with only edges), though this is not logically impossible. If a specific need arises, this could change in future. \u21a9 Since there is no provision for a boundary_dimension attribute, the boundary dimension is always the first dimension of a boundary_node_connectivity , and its second dimension must always be 2 (i.e. it cannot be transposed). If a specific need arises, this could change in future. \u21a9 Requirements on values of variables may not always be practical to check, since this requires loading all of their data. \u21a9 \u21a9 \u21a9 The form of the global Conventions attribute is determined by the CF conformance pages , section 2.6.1. However, the definition of UGRID release numbers is not yet finalised. \u21a9 Providing stable statement references allows conformance statements to evolve without invalidating earlier versions of a checker program. We also provide a linkable web anchor for each one. \u21a9 if a mesh does not share any element dimensions with other meshes, it follows that it also will not share any element coordinates or connectivities with other meshes. \u21a9 invalid \u2018lookalike\u2019 attributes, which are not defined by UGRID, include such as : \u201cnode_face_connectivity\u201d, \u201cboundary_coordinates\u201d, \u201cboundary_dimension\u201d or \u201cnode_dimension\u201d. \u21a9 for checking purposes, the identity of a connectivity is actually defined by the referring attribute in the parent mesh. However, if the connectivity is correctly formed, then its cf_role value will always be the same as this \u2013 cf: R303 . \u21a9 \u21a9 in the present latest CF version the only cf_role terms defined are the discrete-geometry types : timeseries_id , profile_id and trajectory_id \u21a9","title":"Other recommendations"},{"location":"ugrid-subsetting/","text":"UGRID Subsetting \uf0c1 Introduction \uf0c1 This project, and accompanying document, are all about a NetCDF standard for describing unstructured grids and the data/model results stored on them. Having such a standard is key to interoperability between different modeling systems and post-processing tools, etc. Once NetCDF supports this access protocols like Open-source Project for a Network Data Access Protocol (OPeNDAP) can be used. However, there is an additional challenge. Modern unstructured grid models can use very large grids and thus produce extremely large results sets. However, a particular client application may only need a spatial subset of that data. Ideally, there would be a way for a client to download only the portion of the model domain required. With structured grids, you can make good use of OPeNDAP\u2019s ability to slice arrays to get a subset of the data that is useful. However, with UGRIDs, data in a contiguous region in the spatial domain is generally not contiguous in the data arrays. So to do subsetting, the system needs to understand the topology of the grid, select the appropriate discontiguous subset of the data and grid, and put all that together into a still-correct UGRID dataset. This can be done on the client side, figuring out the grid geometry and requesting the required data via OPeNDAP. However, OPeNDAP does not support requesting discontiguous data, so it is necessary to make many small requests to the server and put it back together on the client. This not only means a lot of complex client-side code, but it\u2019s also painfully slow to do many small requests, rather than one large one. In fact, with some testing, for anything but tiny subsets, it\u2019s faster to grab the entire grid than make many small requests for a subset. OPeNDAP subsetting protocol \uf0c1 To address this issue, OPeNDAP, Inc., under a grant from NOAA, has developed an extension to the Hyrax server that supports server-side subsetting of UGRIDs via OPeNDAP server-side functions. As the implementation uses the existing OPeNDAP server-side function protocol, it should be usable with standard OPeNDAP clients, and it should be possible to implement the functionally with the same application programming interface (API), in any OPeNDAP server. Documentation of the server-side function API is here: UGRID subsetting docs Hyrax implementation \uf0c1 Recent development builds of Hyrax include the new functionality, so it should be available in the next Hyrax release. The source code for the Hyrax implementation is here: Hyrax subsetting code GridFields \uf0c1 The subsetting code in the Hyrax server is implemented by the GridFields library. The source code for the version of GridFields can be found here: GridFields source The GridFields library has a much broader scope of capabilities than is utilized with this simple subsetting function, and could be used for a number of other UGRID-manipulating and evaluating tasks. Other OPeNDAP servers. \uf0c1 As of this writing, I am unaware of any other implementations of server-side subsetting in an OPeNDAP server. However it is hoped that other OPeNDAP servers will add such functionality eventually, and hopefully using the same API, as documented by the document linked to above. Gridfields is written in C++, and thus could be used with any other server that can call C++. It also has Python bindings, and thus could be used with a Python implementation, such as PyDAP . Alternatively, the same functionality could be implemented with a different library for the subsetting code itself. Perhaps a Java library for use with the THREDDS server.","title":"UGRID Subsetting"},{"location":"ugrid-subsetting/#ugrid-subsetting","text":"","title":"UGRID Subsetting"},{"location":"ugrid-subsetting/#introduction","text":"This project, and accompanying document, are all about a NetCDF standard for describing unstructured grids and the data/model results stored on them. Having such a standard is key to interoperability between different modeling systems and post-processing tools, etc. Once NetCDF supports this access protocols like Open-source Project for a Network Data Access Protocol (OPeNDAP) can be used. However, there is an additional challenge. Modern unstructured grid models can use very large grids and thus produce extremely large results sets. However, a particular client application may only need a spatial subset of that data. Ideally, there would be a way for a client to download only the portion of the model domain required. With structured grids, you can make good use of OPeNDAP\u2019s ability to slice arrays to get a subset of the data that is useful. However, with UGRIDs, data in a contiguous region in the spatial domain is generally not contiguous in the data arrays. So to do subsetting, the system needs to understand the topology of the grid, select the appropriate discontiguous subset of the data and grid, and put all that together into a still-correct UGRID dataset. This can be done on the client side, figuring out the grid geometry and requesting the required data via OPeNDAP. However, OPeNDAP does not support requesting discontiguous data, so it is necessary to make many small requests to the server and put it back together on the client. This not only means a lot of complex client-side code, but it\u2019s also painfully slow to do many small requests, rather than one large one. In fact, with some testing, for anything but tiny subsets, it\u2019s faster to grab the entire grid than make many small requests for a subset.","title":"Introduction"},{"location":"ugrid-subsetting/#opendap-subsetting-protocol","text":"To address this issue, OPeNDAP, Inc., under a grant from NOAA, has developed an extension to the Hyrax server that supports server-side subsetting of UGRIDs via OPeNDAP server-side functions. As the implementation uses the existing OPeNDAP server-side function protocol, it should be usable with standard OPeNDAP clients, and it should be possible to implement the functionally with the same application programming interface (API), in any OPeNDAP server. Documentation of the server-side function API is here: UGRID subsetting docs","title":"OPeNDAP subsetting protocol"},{"location":"ugrid-subsetting/#hyrax-implementation","text":"Recent development builds of Hyrax include the new functionality, so it should be available in the next Hyrax release. The source code for the Hyrax implementation is here: Hyrax subsetting code","title":"Hyrax implementation"},{"location":"ugrid-subsetting/#gridfields","text":"The subsetting code in the Hyrax server is implemented by the GridFields library. The source code for the version of GridFields can be found here: GridFields source The GridFields library has a much broader scope of capabilities than is utilized with this simple subsetting function, and could be used for a number of other UGRID-manipulating and evaluating tasks.","title":"GridFields"},{"location":"ugrid-subsetting/#other-opendap-servers","text":"As of this writing, I am unaware of any other implementations of server-side subsetting in an OPeNDAP server. However it is hoped that other OPeNDAP servers will add such functionality eventually, and hopefully using the same API, as documented by the document linked to above. Gridfields is written in C++, and thus could be used with any other server that can call C++. It also has Python bindings, and thus could be used with a Python implementation, such as PyDAP . Alternatively, the same functionality could be implemented with a different library for the subsetting code itself. Perhaps a Java library for use with the THREDDS server.","title":"Other OPeNDAP servers."}]}